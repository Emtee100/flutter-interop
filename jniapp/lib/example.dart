// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `androidx.health.connect.client.HealthConnectClient$Companion$AvailabilityStatus`
class HealthConnectClient$Companion$AvailabilityStatus extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<HealthConnectClient$Companion$AvailabilityStatus> $type;

  @jni$_.internal
  HealthConnectClient$Companion$AvailabilityStatus.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/health/connect/client/HealthConnectClient$Companion$AvailabilityStatus',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $HealthConnectClient$Companion$AvailabilityStatus$NullableType();
  static const type = $HealthConnectClient$Companion$AvailabilityStatus$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<
    int,
    $HealthConnectClient$Companion$AvailabilityStatus
  >
  _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $HealthConnectClient$Companion$AvailabilityStatus $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.health.connect.client.HealthConnectClient$Companion$AvailabilityStatus',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory HealthConnectClient$Companion$AvailabilityStatus.implement(
    $HealthConnectClient$Companion$AvailabilityStatus $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return HealthConnectClient$Companion$AvailabilityStatus.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $HealthConnectClient$Companion$AvailabilityStatus {
  factory $HealthConnectClient$Companion$AvailabilityStatus() =
      _$HealthConnectClient$Companion$AvailabilityStatus;
}

final class _$HealthConnectClient$Companion$AvailabilityStatus
    with $HealthConnectClient$Companion$AvailabilityStatus {
  _$HealthConnectClient$Companion$AvailabilityStatus();
}

final class $HealthConnectClient$Companion$AvailabilityStatus$NullableType
    extends jni$_.JObjType<HealthConnectClient$Companion$AvailabilityStatus?> {
  @jni$_.internal
  const $HealthConnectClient$Companion$AvailabilityStatus$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/HealthConnectClient$Companion$AvailabilityStatus;';

  @jni$_.internal
  @core$_.override
  HealthConnectClient$Companion$AvailabilityStatus? fromReference(
    jni$_.JReference reference,
  ) =>
      reference.isNull
          ? null
          : HealthConnectClient$Companion$AvailabilityStatus.fromReference(
            reference,
          );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<HealthConnectClient$Companion$AvailabilityStatus?>
  get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($HealthConnectClient$Companion$AvailabilityStatus$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($HealthConnectClient$Companion$AvailabilityStatus$NullableType) &&
        other is $HealthConnectClient$Companion$AvailabilityStatus$NullableType;
  }
}

final class $HealthConnectClient$Companion$AvailabilityStatus$Type
    extends jni$_.JObjType<HealthConnectClient$Companion$AvailabilityStatus> {
  @jni$_.internal
  const $HealthConnectClient$Companion$AvailabilityStatus$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/HealthConnectClient$Companion$AvailabilityStatus;';

  @jni$_.internal
  @core$_.override
  HealthConnectClient$Companion$AvailabilityStatus fromReference(
    jni$_.JReference reference,
  ) =>
      HealthConnectClient$Companion$AvailabilityStatus.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<HealthConnectClient$Companion$AvailabilityStatus?>
  get nullableType =>
      const $HealthConnectClient$Companion$AvailabilityStatus$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($HealthConnectClient$Companion$AvailabilityStatus$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($HealthConnectClient$Companion$AvailabilityStatus$Type) &&
        other is $HealthConnectClient$Companion$AvailabilityStatus$Type;
  }
}

/// from: `androidx.health.connect.client.HealthConnectClient$Companion`
class HealthConnectClient$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<HealthConnectClient$Companion> $type;

  @jni$_.internal
  HealthConnectClient$Companion.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/health/connect/client/HealthConnectClient$Companion',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $HealthConnectClient$Companion$NullableType();
  static const type = $HealthConnectClient$Companion$Type();
  static final _id_DEFAULT_PROVIDER_PACKAGE_NAME = _class.staticFieldId(
    r'DEFAULT_PROVIDER_PACKAGE_NAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DEFAULT_PROVIDER_PACKAGE_NAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString get DEFAULT_PROVIDER_PACKAGE_NAME =>
      _id_DEFAULT_PROVIDER_PACKAGE_NAME.get(_class, const jni$_.JStringType());

  /// from: `static public final int DEFAULT_PROVIDER_MIN_VERSION_CODE`
  static const DEFAULT_PROVIDER_MIN_VERSION_CODE = 68623;

  /// from: `static public final int SDK_UNAVAILABLE`
  static const SDK_UNAVAILABLE = 1;

  /// from: `static public final int SDK_UNAVAILABLE_PROVIDER_UPDATE_REQUIRED`
  static const SDK_UNAVAILABLE_PROVIDER_UPDATE_REQUIRED = 2;

  /// from: `static public final int SDK_AVAILABLE`
  static const SDK_AVAILABLE = 3;
  static final _id_HEALTH_CONNECT_CLIENT_TAG = _class.staticFieldId(
    r'HEALTH_CONNECT_CLIENT_TAG',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String HEALTH_CONNECT_CLIENT_TAG`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString get HEALTH_CONNECT_CLIENT_TAG =>
      _id_HEALTH_CONNECT_CLIENT_TAG.get(_class, const jni$_.JStringType());

  static final _id_getHealthConnectSettingsAction = _class.instanceMethodId(
    r'getHealthConnectSettingsAction',
    r'()Ljava/lang/String;',
  );

  static final _getHealthConnectSettingsAction =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getHealthConnectSettingsAction()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getHealthConnectSettingsAction() {
    return _getHealthConnectSettingsAction(
      reference.pointer,
      _id_getHealthConnectSettingsAction as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getSdkStatus = _class.instanceMethodId(
    r'getSdkStatus',
    r'(Landroid/content/Context;Ljava/lang/String;)I',
  );

  static final _getSdkStatus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final int getSdkStatus(android.content.Context context, java.lang.String string)`
  int getSdkStatus(Context context, jni$_.JString string) {
    final _$context = context.reference;
    final _$string = string.reference;
    return _getSdkStatus(
      reference.pointer,
      _id_getSdkStatus as jni$_.JMethodIDPtr,
      _$context.pointer,
      _$string.pointer,
    ).integer;
  }

  static final _id_getOrCreate = _class.instanceMethodId(
    r'getOrCreate',
    r'(Landroid/content/Context;Ljava/lang/String;)Landroidx/health/connect/client/HealthConnectClient;',
  );

  static final _getOrCreate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final androidx.health.connect.client.HealthConnectClient getOrCreate(android.content.Context context, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  HealthConnectClient getOrCreate(Context context, jni$_.JString string) {
    final _$context = context.reference;
    final _$string = string.reference;
    return _getOrCreate(
      reference.pointer,
      _id_getOrCreate as jni$_.JMethodIDPtr,
      _$context.pointer,
      _$string.pointer,
    ).object<HealthConnectClient>(const $HealthConnectClient$Type());
  }

  static final _id_getHealthConnectManageDataIntent = _class.instanceMethodId(
    r'getHealthConnectManageDataIntent',
    r'(Landroid/content/Context;Ljava/lang/String;)Landroid/content/Intent;',
  );

  static final _getHealthConnectManageDataIntent =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final android.content.Intent getHealthConnectManageDataIntent(android.content.Context context, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getHealthConnectManageDataIntent(
    Context context,
    jni$_.JString string,
  ) {
    final _$context = context.reference;
    final _$string = string.reference;
    return _getHealthConnectManageDataIntent(
      reference.pointer,
      _id_getHealthConnectManageDataIntent as jni$_.JMethodIDPtr,
      _$context.pointer,
      _$string.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getSdkStatus$1 = _class.instanceMethodId(
    r'getSdkStatus',
    r'(Landroid/content/Context;)I',
  );

  static final _getSdkStatus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final int getSdkStatus(android.content.Context context)`
  int getSdkStatus$1(Context context) {
    final _$context = context.reference;
    return _getSdkStatus$1(
      reference.pointer,
      _id_getSdkStatus$1 as jni$_.JMethodIDPtr,
      _$context.pointer,
    ).integer;
  }

  static final _id_getOrCreate$1 = _class.instanceMethodId(
    r'getOrCreate',
    r'(Landroid/content/Context;)Landroidx/health/connect/client/HealthConnectClient;',
  );

  static final _getOrCreate$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final androidx.health.connect.client.HealthConnectClient getOrCreate(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  HealthConnectClient getOrCreate$1(Context context) {
    final _$context = context.reference;
    return _getOrCreate$1(
      reference.pointer,
      _id_getOrCreate$1 as jni$_.JMethodIDPtr,
      _$context.pointer,
    ).object<HealthConnectClient>(const $HealthConnectClient$Type());
  }

  static final _id_getHealthConnectManageDataIntent$1 = _class.instanceMethodId(
    r'getHealthConnectManageDataIntent',
    r'(Landroid/content/Context;)Landroid/content/Intent;',
  );

  static final _getHealthConnectManageDataIntent$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final android.content.Intent getHealthConnectManageDataIntent(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getHealthConnectManageDataIntent$1(Context context) {
    final _$context = context.reference;
    return _getHealthConnectManageDataIntent$1(
      reference.pointer,
      _id_getHealthConnectManageDataIntent$1 as jni$_.JMethodIDPtr,
      _$context.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
  }
}

final class $HealthConnectClient$Companion$NullableType
    extends jni$_.JObjType<HealthConnectClient$Companion?> {
  @jni$_.internal
  const $HealthConnectClient$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/HealthConnectClient$Companion;';

  @jni$_.internal
  @core$_.override
  HealthConnectClient$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : HealthConnectClient$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<HealthConnectClient$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($HealthConnectClient$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($HealthConnectClient$Companion$NullableType) &&
        other is $HealthConnectClient$Companion$NullableType;
  }
}

final class $HealthConnectClient$Companion$Type
    extends jni$_.JObjType<HealthConnectClient$Companion> {
  @jni$_.internal
  const $HealthConnectClient$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/HealthConnectClient$Companion;';

  @jni$_.internal
  @core$_.override
  HealthConnectClient$Companion fromReference(jni$_.JReference reference) =>
      HealthConnectClient$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<HealthConnectClient$Companion?> get nullableType =>
      const $HealthConnectClient$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($HealthConnectClient$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($HealthConnectClient$Companion$Type) &&
        other is $HealthConnectClient$Companion$Type;
  }
}

/// from: `androidx.health.connect.client.HealthConnectClient$DefaultImpls`
class HealthConnectClient$DefaultImpls extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<HealthConnectClient$DefaultImpls> $type;

  @jni$_.internal
  HealthConnectClient$DefaultImpls.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/health/connect/client/HealthConnectClient$DefaultImpls',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $HealthConnectClient$DefaultImpls$NullableType();
  static const type = $HealthConnectClient$DefaultImpls$Type();
  static final _id_getFeatures = _class.staticMethodId(
    r'getFeatures',
    r'(Landroidx/health/connect/client/HealthConnectClient;)Landroidx/health/connect/client/HealthConnectFeatures;',
  );

  static final _getFeatures =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public androidx.health.connect.client.HealthConnectFeatures getFeatures(androidx.health.connect.client.HealthConnectClient healthConnectClient)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getFeatures(HealthConnectClient healthConnectClient) {
    final _$healthConnectClient = healthConnectClient.reference;
    return _getFeatures(
      _class.reference.pointer,
      _id_getFeatures as jni$_.JMethodIDPtr,
      _$healthConnectClient.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_upsertMedicalResources = _class.staticMethodId(
    r'upsertMedicalResources',
    r'(Landroidx/health/connect/client/HealthConnectClient;Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _upsertMedicalResources =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.Object upsertMedicalResources(androidx.health.connect.client.HealthConnectClient healthConnectClient, java.util.List list, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? upsertMedicalResources(
    HealthConnectClient healthConnectClient,
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JObject continuation,
  ) {
    final _$healthConnectClient = healthConnectClient.reference;
    final _$list = list.reference;
    final _$continuation = continuation.reference;
    return _upsertMedicalResources(
      _class.reference.pointer,
      _id_upsertMedicalResources as jni$_.JMethodIDPtr,
      _$healthConnectClient.pointer,
      _$list.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_readMedicalResources = _class.staticMethodId(
    r'readMedicalResources',
    r'(Landroidx/health/connect/client/HealthConnectClient;Landroidx/health/connect/client/request/ReadMedicalResourcesRequest;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _readMedicalResources =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.Object readMedicalResources(androidx.health.connect.client.HealthConnectClient healthConnectClient, androidx.health.connect.client.request.ReadMedicalResourcesRequest readMedicalResourcesRequest, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? readMedicalResources(
    HealthConnectClient healthConnectClient,
    jni$_.JObject readMedicalResourcesRequest,
    jni$_.JObject continuation,
  ) {
    final _$healthConnectClient = healthConnectClient.reference;
    final _$readMedicalResourcesRequest = readMedicalResourcesRequest.reference;
    final _$continuation = continuation.reference;
    return _readMedicalResources(
      _class.reference.pointer,
      _id_readMedicalResources as jni$_.JMethodIDPtr,
      _$healthConnectClient.pointer,
      _$readMedicalResourcesRequest.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_readMedicalResources$1 = _class.staticMethodId(
    r'readMedicalResources',
    r'(Landroidx/health/connect/client/HealthConnectClient;Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _readMedicalResources$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.Object readMedicalResources(androidx.health.connect.client.HealthConnectClient healthConnectClient, java.util.List list, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? readMedicalResources$1(
    HealthConnectClient healthConnectClient,
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JObject continuation,
  ) {
    final _$healthConnectClient = healthConnectClient.reference;
    final _$list = list.reference;
    final _$continuation = continuation.reference;
    return _readMedicalResources$1(
      _class.reference.pointer,
      _id_readMedicalResources$1 as jni$_.JMethodIDPtr,
      _$healthConnectClient.pointer,
      _$list.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_deleteMedicalResources = _class.staticMethodId(
    r'deleteMedicalResources',
    r'(Landroidx/health/connect/client/HealthConnectClient;Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _deleteMedicalResources =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.Object deleteMedicalResources(androidx.health.connect.client.HealthConnectClient healthConnectClient, java.util.List list, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? deleteMedicalResources(
    HealthConnectClient healthConnectClient,
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JObject continuation,
  ) {
    final _$healthConnectClient = healthConnectClient.reference;
    final _$list = list.reference;
    final _$continuation = continuation.reference;
    return _deleteMedicalResources(
      _class.reference.pointer,
      _id_deleteMedicalResources as jni$_.JMethodIDPtr,
      _$healthConnectClient.pointer,
      _$list.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_deleteMedicalResources$1 = _class.staticMethodId(
    r'deleteMedicalResources',
    r'(Landroidx/health/connect/client/HealthConnectClient;Landroidx/health/connect/client/request/DeleteMedicalResourcesRequest;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _deleteMedicalResources$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.Object deleteMedicalResources(androidx.health.connect.client.HealthConnectClient healthConnectClient, androidx.health.connect.client.request.DeleteMedicalResourcesRequest deleteMedicalResourcesRequest, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? deleteMedicalResources$1(
    HealthConnectClient healthConnectClient,
    jni$_.JObject deleteMedicalResourcesRequest,
    jni$_.JObject continuation,
  ) {
    final _$healthConnectClient = healthConnectClient.reference;
    final _$deleteMedicalResourcesRequest =
        deleteMedicalResourcesRequest.reference;
    final _$continuation = continuation.reference;
    return _deleteMedicalResources$1(
      _class.reference.pointer,
      _id_deleteMedicalResources$1 as jni$_.JMethodIDPtr,
      _$healthConnectClient.pointer,
      _$deleteMedicalResourcesRequest.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_createMedicalDataSource = _class.staticMethodId(
    r'createMedicalDataSource',
    r'(Landroidx/health/connect/client/HealthConnectClient;Landroidx/health/connect/client/request/CreateMedicalDataSourceRequest;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _createMedicalDataSource =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.Object createMedicalDataSource(androidx.health.connect.client.HealthConnectClient healthConnectClient, androidx.health.connect.client.request.CreateMedicalDataSourceRequest createMedicalDataSourceRequest, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? createMedicalDataSource(
    HealthConnectClient healthConnectClient,
    jni$_.JObject createMedicalDataSourceRequest,
    jni$_.JObject continuation,
  ) {
    final _$healthConnectClient = healthConnectClient.reference;
    final _$createMedicalDataSourceRequest =
        createMedicalDataSourceRequest.reference;
    final _$continuation = continuation.reference;
    return _createMedicalDataSource(
      _class.reference.pointer,
      _id_createMedicalDataSource as jni$_.JMethodIDPtr,
      _$healthConnectClient.pointer,
      _$createMedicalDataSourceRequest.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_deleteMedicalDataSourceWithData = _class.staticMethodId(
    r'deleteMedicalDataSourceWithData',
    r'(Landroidx/health/connect/client/HealthConnectClient;Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _deleteMedicalDataSourceWithData =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.Object deleteMedicalDataSourceWithData(androidx.health.connect.client.HealthConnectClient healthConnectClient, java.lang.String string, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? deleteMedicalDataSourceWithData(
    HealthConnectClient healthConnectClient,
    jni$_.JString string,
    jni$_.JObject continuation,
  ) {
    final _$healthConnectClient = healthConnectClient.reference;
    final _$string = string.reference;
    final _$continuation = continuation.reference;
    return _deleteMedicalDataSourceWithData(
      _class.reference.pointer,
      _id_deleteMedicalDataSourceWithData as jni$_.JMethodIDPtr,
      _$healthConnectClient.pointer,
      _$string.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getMedicalDataSources = _class.staticMethodId(
    r'getMedicalDataSources',
    r'(Landroidx/health/connect/client/HealthConnectClient;Landroidx/health/connect/client/request/GetMedicalDataSourcesRequest;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _getMedicalDataSources =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.Object getMedicalDataSources(androidx.health.connect.client.HealthConnectClient healthConnectClient, androidx.health.connect.client.request.GetMedicalDataSourcesRequest getMedicalDataSourcesRequest, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? getMedicalDataSources(
    HealthConnectClient healthConnectClient,
    jni$_.JObject getMedicalDataSourcesRequest,
    jni$_.JObject continuation,
  ) {
    final _$healthConnectClient = healthConnectClient.reference;
    final _$getMedicalDataSourcesRequest =
        getMedicalDataSourcesRequest.reference;
    final _$continuation = continuation.reference;
    return _getMedicalDataSources(
      _class.reference.pointer,
      _id_getMedicalDataSources as jni$_.JMethodIDPtr,
      _$healthConnectClient.pointer,
      _$getMedicalDataSourcesRequest.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getMedicalDataSources$1 = _class.staticMethodId(
    r'getMedicalDataSources',
    r'(Landroidx/health/connect/client/HealthConnectClient;Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _getMedicalDataSources$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.Object getMedicalDataSources(androidx.health.connect.client.HealthConnectClient healthConnectClient, java.util.List list, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? getMedicalDataSources$1(
    HealthConnectClient healthConnectClient,
    jni$_.JList<jni$_.JString?> list,
    jni$_.JObject continuation,
  ) {
    final _$healthConnectClient = healthConnectClient.reference;
    final _$list = list.reference;
    final _$continuation = continuation.reference;
    return _getMedicalDataSources$1(
      _class.reference.pointer,
      _id_getMedicalDataSources$1 as jni$_.JMethodIDPtr,
      _$healthConnectClient.pointer,
      _$list.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $HealthConnectClient$DefaultImpls$NullableType
    extends jni$_.JObjType<HealthConnectClient$DefaultImpls?> {
  @jni$_.internal
  const $HealthConnectClient$DefaultImpls$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/HealthConnectClient$DefaultImpls;';

  @jni$_.internal
  @core$_.override
  HealthConnectClient$DefaultImpls? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : HealthConnectClient$DefaultImpls.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<HealthConnectClient$DefaultImpls?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($HealthConnectClient$DefaultImpls$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($HealthConnectClient$DefaultImpls$NullableType) &&
        other is $HealthConnectClient$DefaultImpls$NullableType;
  }
}

final class $HealthConnectClient$DefaultImpls$Type
    extends jni$_.JObjType<HealthConnectClient$DefaultImpls> {
  @jni$_.internal
  const $HealthConnectClient$DefaultImpls$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/HealthConnectClient$DefaultImpls;';

  @jni$_.internal
  @core$_.override
  HealthConnectClient$DefaultImpls fromReference(jni$_.JReference reference) =>
      HealthConnectClient$DefaultImpls.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<HealthConnectClient$DefaultImpls?> get nullableType =>
      const $HealthConnectClient$DefaultImpls$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($HealthConnectClient$DefaultImpls$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($HealthConnectClient$DefaultImpls$Type) &&
        other is $HealthConnectClient$DefaultImpls$Type;
  }
}

/// from: `androidx.health.connect.client.HealthConnectClient`
class HealthConnectClient extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<HealthConnectClient> $type;

  @jni$_.internal
  HealthConnectClient.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/health/connect/client/HealthConnectClient',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $HealthConnectClient$NullableType();
  static const type = $HealthConnectClient$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Landroidx/health/connect/client/HealthConnectClient$Companion;',
  );

  /// from: `static public final androidx.health.connect.client.HealthConnectClient$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static HealthConnectClient$Companion get Companion =>
      _id_Companion.get(_class, const $HealthConnectClient$Companion$Type());

  static final _id_DEFAULT_PROVIDER_PACKAGE_NAME = _class.staticFieldId(
    r'DEFAULT_PROVIDER_PACKAGE_NAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DEFAULT_PROVIDER_PACKAGE_NAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString get DEFAULT_PROVIDER_PACKAGE_NAME =>
      _id_DEFAULT_PROVIDER_PACKAGE_NAME.get(_class, const jni$_.JStringType());

  /// from: `static public final int DEFAULT_PROVIDER_MIN_VERSION_CODE`
  static const DEFAULT_PROVIDER_MIN_VERSION_CODE = 68623;

  /// from: `static public final int SDK_UNAVAILABLE`
  static const SDK_UNAVAILABLE = 1;

  /// from: `static public final int SDK_UNAVAILABLE_PROVIDER_UPDATE_REQUIRED`
  static const SDK_UNAVAILABLE_PROVIDER_UPDATE_REQUIRED = 2;

  /// from: `static public final int SDK_AVAILABLE`
  static const SDK_AVAILABLE = 3;
  static final _id_HEALTH_CONNECT_CLIENT_TAG = _class.staticFieldId(
    r'HEALTH_CONNECT_CLIENT_TAG',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String HEALTH_CONNECT_CLIENT_TAG`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString get HEALTH_CONNECT_CLIENT_TAG =>
      _id_HEALTH_CONNECT_CLIENT_TAG.get(_class, const jni$_.JStringType());

  static final _id_getPermissionController = _class.instanceMethodId(
    r'getPermissionController',
    r'()Landroidx/health/connect/client/PermissionController;',
  );

  static final _getPermissionController =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract androidx.health.connect.client.PermissionController getPermissionController()`
  /// The returned object must be released after use, by calling the [release] method.
  PermissionController getPermissionController() {
    return _getPermissionController(
      reference.pointer,
      _id_getPermissionController as jni$_.JMethodIDPtr,
    ).object<PermissionController>(const $PermissionController$Type());
  }

  static final _id_getFeatures = _class.instanceMethodId(
    r'getFeatures',
    r'()Landroidx/health/connect/client/HealthConnectFeatures;',
  );

  static final _getFeatures =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.health.connect.client.HealthConnectFeatures getFeatures()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getFeatures() {
    return _getFeatures(
      reference.pointer,
      _id_getFeatures as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_insertRecords = _class.instanceMethodId(
    r'insertRecords',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _insertRecords =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.lang.Object insertRecords(java.util.List list, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> insertRecords(
    jni$_.JList<jni$_.JObject?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _insertRecords(
      reference.pointer,
      _id_insertRecords as jni$_.JMethodIDPtr,
      _$list.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress(await $p.first)),
      );
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.JObjectType(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as(const jni$_.JObjectType(), releaseOriginal: true);
  }

  static final _id_updateRecords = _class.instanceMethodId(
    r'updateRecords',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _updateRecords =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.lang.Object updateRecords(java.util.List list, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> updateRecords(
    jni$_.JList<jni$_.JObject?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _updateRecords(
      reference.pointer,
      _id_updateRecords as jni$_.JMethodIDPtr,
      _$list.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress(await $p.first)),
      );
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.JObjectType(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as(const jni$_.JObjectType(), releaseOriginal: true);
  }

  static final _id_deleteRecords = _class.instanceMethodId(
    r'deleteRecords',
    r'(Lkotlin/reflect/KClass;Ljava/util/List;Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _deleteRecords =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.lang.Object deleteRecords(kotlin.reflect.KClass kClass, java.util.List list, java.util.List list1, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> deleteRecords(
    jni$_.JObject kClass,
    jni$_.JList<jni$_.JString?> list,
    jni$_.JList<jni$_.JString?> list1,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$kClass = kClass.reference;
    final _$list = list.reference;
    final _$list1 = list1.reference;
    final $r = _deleteRecords(
      reference.pointer,
      _id_deleteRecords as jni$_.JMethodIDPtr,
      _$kClass.pointer,
      _$list.pointer,
      _$list1.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress(await $p.first)),
      );
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.JObjectType(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as(const jni$_.JObjectType(), releaseOriginal: true);
  }

  static final _id_deleteRecords$1 = _class.instanceMethodId(
    r'deleteRecords',
    r'(Lkotlin/reflect/KClass;Landroidx/health/connect/client/time/TimeRangeFilter;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _deleteRecords$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.lang.Object deleteRecords(kotlin.reflect.KClass kClass, androidx.health.connect.client.time.TimeRangeFilter timeRangeFilter, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> deleteRecords$1(
    jni$_.JObject kClass,
    TimeRangeFilter timeRangeFilter,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$kClass = kClass.reference;
    final _$timeRangeFilter = timeRangeFilter.reference;
    final $r = _deleteRecords$1(
      reference.pointer,
      _id_deleteRecords$1 as jni$_.JMethodIDPtr,
      _$kClass.pointer,
      _$timeRangeFilter.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress(await $p.first)),
      );
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.JObjectType(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as(const jni$_.JObjectType(), releaseOriginal: true);
  }

  static final _id_readRecord = _class.instanceMethodId(
    r'readRecord',
    r'(Lkotlin/reflect/KClass;Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _readRecord =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.lang.Object readRecord(kotlin.reflect.KClass kClass, java.lang.String string, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> readRecord<$T extends jni$_.JObject>(
    jni$_.JObject kClass,
    jni$_.JString string, {
    required jni$_.JObjType<$T> T,
  }) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$kClass = kClass.reference;
    final _$string = string.reference;
    final $r = _readRecord(
      reference.pointer,
      _id_readRecord as jni$_.JMethodIDPtr,
      _$kClass.pointer,
      _$string.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress(await $p.first)),
      );
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.JObjectType(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as(const jni$_.JObjectType(), releaseOriginal: true);
  }

  static final _id_readRecords = _class.instanceMethodId(
    r'readRecords',
    r'(Landroidx/health/connect/client/request/ReadRecordsRequest;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _readRecords =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.lang.Object readRecords(androidx.health.connect.client.request.ReadRecordsRequest readRecordsRequest, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> readRecords<$T extends jni$_.JObject>(
    jni$_.JObject readRecordsRequest, {
    required jni$_.JObjType<$T> T,
  }) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$readRecordsRequest = readRecordsRequest.reference;
    final $r = _readRecords(
      reference.pointer,
      _id_readRecords as jni$_.JMethodIDPtr,
      _$readRecordsRequest.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress(await $p.first)),
      );
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.JObjectType(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as(const jni$_.JObjectType(), releaseOriginal: true);
  }

  static final _id_aggregate = _class.instanceMethodId(
    r'aggregate',
    r'(Landroidx/health/connect/client/request/AggregateRequest;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _aggregate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.lang.Object aggregate(androidx.health.connect.client.request.AggregateRequest aggregateRequest, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<AggregationResult> aggregate(
    AggregateRequest aggregateRequest,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$aggregateRequest = aggregateRequest.reference;
    final $r = _aggregate(
      reference.pointer,
      _id_aggregate as jni$_.JMethodIDPtr,
      _$aggregateRequest.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress(await $p.first)),
      );
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.JObjectType(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as(const $AggregationResult$Type(), releaseOriginal: true);
  }

  static final _id_aggregateGroupByDuration = _class.instanceMethodId(
    r'aggregateGroupByDuration',
    r'(Landroidx/health/connect/client/request/AggregateGroupByDurationRequest;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _aggregateGroupByDuration =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.lang.Object aggregateGroupByDuration(androidx.health.connect.client.request.AggregateGroupByDurationRequest aggregateGroupByDurationRequest, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<jni$_.JObject>> aggregateGroupByDuration(
    jni$_.JObject aggregateGroupByDurationRequest,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$aggregateGroupByDurationRequest =
        aggregateGroupByDurationRequest.reference;
    final $r = _aggregateGroupByDuration(
      reference.pointer,
      _id_aggregateGroupByDuration as jni$_.JMethodIDPtr,
      _$aggregateGroupByDurationRequest.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress(await $p.first)),
      );
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.JObjectType(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as(
      const jni$_.JListType<jni$_.JObject>(jni$_.JObjectType()),
      releaseOriginal: true,
    );
  }

  static final _id_aggregateGroupByPeriod = _class.instanceMethodId(
    r'aggregateGroupByPeriod',
    r'(Landroidx/health/connect/client/request/AggregateGroupByPeriodRequest;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _aggregateGroupByPeriod =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.lang.Object aggregateGroupByPeriod(androidx.health.connect.client.request.AggregateGroupByPeriodRequest aggregateGroupByPeriodRequest, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<jni$_.JObject>> aggregateGroupByPeriod(
    jni$_.JObject aggregateGroupByPeriodRequest,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$aggregateGroupByPeriodRequest =
        aggregateGroupByPeriodRequest.reference;
    final $r = _aggregateGroupByPeriod(
      reference.pointer,
      _id_aggregateGroupByPeriod as jni$_.JMethodIDPtr,
      _$aggregateGroupByPeriodRequest.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress(await $p.first)),
      );
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.JObjectType(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as(
      const jni$_.JListType<jni$_.JObject>(jni$_.JObjectType()),
      releaseOriginal: true,
    );
  }

  static final _id_getChangesToken = _class.instanceMethodId(
    r'getChangesToken',
    r'(Landroidx/health/connect/client/request/ChangesTokenRequest;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _getChangesToken =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.lang.Object getChangesToken(androidx.health.connect.client.request.ChangesTokenRequest changesTokenRequest, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JString> getChangesToken(
    jni$_.JObject changesTokenRequest,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$changesTokenRequest = changesTokenRequest.reference;
    final $r = _getChangesToken(
      reference.pointer,
      _id_getChangesToken as jni$_.JMethodIDPtr,
      _$changesTokenRequest.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress(await $p.first)),
      );
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.JObjectType(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as(const jni$_.JStringType(), releaseOriginal: true);
  }

  static final _id_getChanges = _class.instanceMethodId(
    r'getChanges',
    r'(Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _getChanges =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.lang.Object getChanges(java.lang.String string, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> getChanges(jni$_.JString string) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$string = string.reference;
    final $r = _getChanges(
      reference.pointer,
      _id_getChanges as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress(await $p.first)),
      );
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.JObjectType(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as(const jni$_.JObjectType(), releaseOriginal: true);
  }

  static final _id_upsertMedicalResources = _class.instanceMethodId(
    r'upsertMedicalResources',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _upsertMedicalResources =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.Object upsertMedicalResources(java.util.List list, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<jni$_.JObject>> upsertMedicalResources(
    jni$_.JList<jni$_.JObject?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _upsertMedicalResources(
      reference.pointer,
      _id_upsertMedicalResources as jni$_.JMethodIDPtr,
      _$list.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress(await $p.first)),
      );
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.JObjectType(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as(
      const jni$_.JListType<jni$_.JObject>(jni$_.JObjectType()),
      releaseOriginal: true,
    );
  }

  static final _id_readMedicalResources = _class.instanceMethodId(
    r'readMedicalResources',
    r'(Landroidx/health/connect/client/request/ReadMedicalResourcesRequest;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _readMedicalResources =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.Object readMedicalResources(androidx.health.connect.client.request.ReadMedicalResourcesRequest readMedicalResourcesRequest, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> readMedicalResources(
    jni$_.JObject readMedicalResourcesRequest,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$readMedicalResourcesRequest = readMedicalResourcesRequest.reference;
    final $r = _readMedicalResources(
      reference.pointer,
      _id_readMedicalResources as jni$_.JMethodIDPtr,
      _$readMedicalResourcesRequest.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress(await $p.first)),
      );
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.JObjectType(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as(const jni$_.JObjectType(), releaseOriginal: true);
  }

  static final _id_readMedicalResources$1 = _class.instanceMethodId(
    r'readMedicalResources',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _readMedicalResources$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.Object readMedicalResources(java.util.List list, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<jni$_.JObject>> readMedicalResources$1(
    jni$_.JList<jni$_.JObject?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _readMedicalResources$1(
      reference.pointer,
      _id_readMedicalResources$1 as jni$_.JMethodIDPtr,
      _$list.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress(await $p.first)),
      );
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.JObjectType(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as(
      const jni$_.JListType<jni$_.JObject>(jni$_.JObjectType()),
      releaseOriginal: true,
    );
  }

  static final _id_deleteMedicalResources = _class.instanceMethodId(
    r'deleteMedicalResources',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _deleteMedicalResources =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.Object deleteMedicalResources(java.util.List list, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> deleteMedicalResources(
    jni$_.JList<jni$_.JObject?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _deleteMedicalResources(
      reference.pointer,
      _id_deleteMedicalResources as jni$_.JMethodIDPtr,
      _$list.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress(await $p.first)),
      );
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.JObjectType(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as(const jni$_.JObjectType(), releaseOriginal: true);
  }

  static final _id_deleteMedicalResources$1 = _class.instanceMethodId(
    r'deleteMedicalResources',
    r'(Landroidx/health/connect/client/request/DeleteMedicalResourcesRequest;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _deleteMedicalResources$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.Object deleteMedicalResources(androidx.health.connect.client.request.DeleteMedicalResourcesRequest deleteMedicalResourcesRequest, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> deleteMedicalResources$1(
    jni$_.JObject deleteMedicalResourcesRequest,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$deleteMedicalResourcesRequest =
        deleteMedicalResourcesRequest.reference;
    final $r = _deleteMedicalResources$1(
      reference.pointer,
      _id_deleteMedicalResources$1 as jni$_.JMethodIDPtr,
      _$deleteMedicalResourcesRequest.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress(await $p.first)),
      );
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.JObjectType(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as(const jni$_.JObjectType(), releaseOriginal: true);
  }

  static final _id_createMedicalDataSource = _class.instanceMethodId(
    r'createMedicalDataSource',
    r'(Landroidx/health/connect/client/request/CreateMedicalDataSourceRequest;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _createMedicalDataSource =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.Object createMedicalDataSource(androidx.health.connect.client.request.CreateMedicalDataSourceRequest createMedicalDataSourceRequest, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> createMedicalDataSource(
    jni$_.JObject createMedicalDataSourceRequest,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$createMedicalDataSourceRequest =
        createMedicalDataSourceRequest.reference;
    final $r = _createMedicalDataSource(
      reference.pointer,
      _id_createMedicalDataSource as jni$_.JMethodIDPtr,
      _$createMedicalDataSourceRequest.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress(await $p.first)),
      );
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.JObjectType(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as(const jni$_.JObjectType(), releaseOriginal: true);
  }

  static final _id_deleteMedicalDataSourceWithData = _class.instanceMethodId(
    r'deleteMedicalDataSourceWithData',
    r'(Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _deleteMedicalDataSourceWithData =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.Object deleteMedicalDataSourceWithData(java.lang.String string, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> deleteMedicalDataSourceWithData(
    jni$_.JString string,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$string = string.reference;
    final $r = _deleteMedicalDataSourceWithData(
      reference.pointer,
      _id_deleteMedicalDataSourceWithData as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress(await $p.first)),
      );
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.JObjectType(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as(const jni$_.JObjectType(), releaseOriginal: true);
  }

  static final _id_getMedicalDataSources = _class.instanceMethodId(
    r'getMedicalDataSources',
    r'(Landroidx/health/connect/client/request/GetMedicalDataSourcesRequest;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _getMedicalDataSources =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.Object getMedicalDataSources(androidx.health.connect.client.request.GetMedicalDataSourcesRequest getMedicalDataSourcesRequest, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<jni$_.JObject>> getMedicalDataSources(
    jni$_.JObject getMedicalDataSourcesRequest,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$getMedicalDataSourcesRequest =
        getMedicalDataSourcesRequest.reference;
    final $r = _getMedicalDataSources(
      reference.pointer,
      _id_getMedicalDataSources as jni$_.JMethodIDPtr,
      _$getMedicalDataSourcesRequest.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress(await $p.first)),
      );
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.JObjectType(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as(
      const jni$_.JListType<jni$_.JObject>(jni$_.JObjectType()),
      releaseOriginal: true,
    );
  }

  static final _id_getMedicalDataSources$1 = _class.instanceMethodId(
    r'getMedicalDataSources',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _getMedicalDataSources$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.Object getMedicalDataSources(java.util.List list, kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<jni$_.JObject>> getMedicalDataSources$1(
    jni$_.JList<jni$_.JString?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _getMedicalDataSources$1(
      reference.pointer,
      _id_getMedicalDataSources$1 as jni$_.JMethodIDPtr,
      _$list.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress(await $p.first)),
      );
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.JObjectType(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as(
      const jni$_.JListType<jni$_.JObject>(jni$_.JObjectType()),
      releaseOriginal: true,
    );
  }

  static final _id_getHealthConnectSettingsAction = _class.staticMethodId(
    r'getHealthConnectSettingsAction',
    r'()Ljava/lang/String;',
  );

  static final _getHealthConnectSettingsAction =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.lang.String getHealthConnectSettingsAction()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString getHealthConnectSettingsAction() {
    return _getHealthConnectSettingsAction(
      _class.reference.pointer,
      _id_getHealthConnectSettingsAction as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getSdkStatus = _class.staticMethodId(
    r'getSdkStatus',
    r'(Landroid/content/Context;Ljava/lang/String;)I',
  );

  static final _getSdkStatus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public int getSdkStatus(android.content.Context context, java.lang.String string)`
  static int getSdkStatus(Context context, jni$_.JString string) {
    final _$context = context.reference;
    final _$string = string.reference;
    return _getSdkStatus(
      _class.reference.pointer,
      _id_getSdkStatus as jni$_.JMethodIDPtr,
      _$context.pointer,
      _$string.pointer,
    ).integer;
  }

  static final _id_getOrCreate = _class.staticMethodId(
    r'getOrCreate',
    r'(Landroid/content/Context;Ljava/lang/String;)Landroidx/health/connect/client/HealthConnectClient;',
  );

  static final _getOrCreate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public androidx.health.connect.client.HealthConnectClient getOrCreate(android.content.Context context, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static HealthConnectClient getOrCreate(
    Context context,
    jni$_.JString string,
  ) {
    final _$context = context.reference;
    final _$string = string.reference;
    return _getOrCreate(
      _class.reference.pointer,
      _id_getOrCreate as jni$_.JMethodIDPtr,
      _$context.pointer,
      _$string.pointer,
    ).object<HealthConnectClient>(const $HealthConnectClient$Type());
  }

  static final _id_getHealthConnectManageDataIntent = _class.staticMethodId(
    r'getHealthConnectManageDataIntent',
    r'(Landroid/content/Context;Ljava/lang/String;)Landroid/content/Intent;',
  );

  static final _getHealthConnectManageDataIntent =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.content.Intent getHealthConnectManageDataIntent(android.content.Context context, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getHealthConnectManageDataIntent(
    Context context,
    jni$_.JString string,
  ) {
    final _$context = context.reference;
    final _$string = string.reference;
    return _getHealthConnectManageDataIntent(
      _class.reference.pointer,
      _id_getHealthConnectManageDataIntent as jni$_.JMethodIDPtr,
      _$context.pointer,
      _$string.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getSdkStatus$1 = _class.staticMethodId(
    r'getSdkStatus',
    r'(Landroid/content/Context;)I',
  );

  static final _getSdkStatus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public int getSdkStatus(android.content.Context context)`
  static int getSdkStatus$1(Context context) {
    final _$context = context.reference;
    return _getSdkStatus$1(
      _class.reference.pointer,
      _id_getSdkStatus$1 as jni$_.JMethodIDPtr,
      _$context.pointer,
    ).integer;
  }

  static final _id_getOrCreate$1 = _class.staticMethodId(
    r'getOrCreate',
    r'(Landroid/content/Context;)Landroidx/health/connect/client/HealthConnectClient;',
  );

  static final _getOrCreate$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public androidx.health.connect.client.HealthConnectClient getOrCreate(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  static HealthConnectClient getOrCreate$1(Context context) {
    final _$context = context.reference;
    return _getOrCreate$1(
      _class.reference.pointer,
      _id_getOrCreate$1 as jni$_.JMethodIDPtr,
      _$context.pointer,
    ).object<HealthConnectClient>(const $HealthConnectClient$Type());
  }

  static final _id_getHealthConnectManageDataIntent$1 = _class.staticMethodId(
    r'getHealthConnectManageDataIntent',
    r'(Landroid/content/Context;)Landroid/content/Intent;',
  );

  static final _getHealthConnectManageDataIntent$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.content.Intent getHealthConnectManageDataIntent(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getHealthConnectManageDataIntent$1(Context context) {
    final _$context = context.reference;
    return _getHealthConnectManageDataIntent$1(
      _class.reference.pointer,
      _id_getHealthConnectManageDataIntent$1 as jni$_.JMethodIDPtr,
      _$context.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $HealthConnectClient> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'getPermissionController()Landroidx/health/connect/client/PermissionController;') {
        final $r = _$impls[$p]!.getPermissionController();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'getFeatures()Landroidx/health/connect/client/HealthConnectFeatures;') {
        final $r = _$impls[$p]!.getFeatures();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'insertRecords(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.insertRecords(
          $a![0]!.as(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()),
            releaseOriginal: true,
          ),
          $a![1]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'updateRecords(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.updateRecords(
          $a![0]!.as(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()),
            releaseOriginal: true,
          ),
          $a![1]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'deleteRecords(Lkotlin/reflect/KClass;Ljava/util/List;Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.deleteRecords(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![1]!.as(
            const jni$_.JListType<jni$_.JString?>(jni$_.JStringNullableType()),
            releaseOriginal: true,
          ),
          $a![2]!.as(
            const jni$_.JListType<jni$_.JString?>(jni$_.JStringNullableType()),
            releaseOriginal: true,
          ),
          $a![3]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'deleteRecords(Lkotlin/reflect/KClass;Landroidx/health/connect/client/time/TimeRangeFilter;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.deleteRecords$1(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![1]!.as(const $TimeRangeFilter$Type(), releaseOriginal: true),
          $a![2]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'readRecord(Lkotlin/reflect/KClass;Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.readRecord(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![1]!.as(const jni$_.JStringType(), releaseOriginal: true),
          $a![2]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'readRecords(Landroidx/health/connect/client/request/ReadRecordsRequest;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.readRecords(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![1]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'aggregate(Landroidx/health/connect/client/request/AggregateRequest;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.aggregate(
          $a![0]!.as(const $AggregateRequest$Type(), releaseOriginal: true),
          $a![1]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'aggregateGroupByDuration(Landroidx/health/connect/client/request/AggregateGroupByDurationRequest;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.aggregateGroupByDuration(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![1]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'aggregateGroupByPeriod(Landroidx/health/connect/client/request/AggregateGroupByPeriodRequest;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.aggregateGroupByPeriod(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![1]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'getChangesToken(Landroidx/health/connect/client/request/ChangesTokenRequest;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.getChangesToken(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![1]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'getChanges(Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.getChanges(
          $a![0]!.as(const jni$_.JStringType(), releaseOriginal: true),
          $a![1]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'upsertMedicalResources(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.upsertMedicalResources(
          $a![0]!.as(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()),
            releaseOriginal: true,
          ),
          $a![1]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'readMedicalResources(Landroidx/health/connect/client/request/ReadMedicalResourcesRequest;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.readMedicalResources(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![1]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'readMedicalResources(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.readMedicalResources$1(
          $a![0]!.as(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()),
            releaseOriginal: true,
          ),
          $a![1]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'deleteMedicalResources(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.deleteMedicalResources(
          $a![0]!.as(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()),
            releaseOriginal: true,
          ),
          $a![1]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'deleteMedicalResources(Landroidx/health/connect/client/request/DeleteMedicalResourcesRequest;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.deleteMedicalResources$1(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![1]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'createMedicalDataSource(Landroidx/health/connect/client/request/CreateMedicalDataSourceRequest;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.createMedicalDataSource(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![1]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'deleteMedicalDataSourceWithData(Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.deleteMedicalDataSourceWithData(
          $a![0]!.as(const jni$_.JStringType(), releaseOriginal: true),
          $a![1]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'getMedicalDataSources(Landroidx/health/connect/client/request/GetMedicalDataSourcesRequest;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.getMedicalDataSources(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![1]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'getMedicalDataSources(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.getMedicalDataSources$1(
          $a![0]!.as(
            const jni$_.JListType<jni$_.JString?>(jni$_.JStringNullableType()),
            releaseOriginal: true,
          ),
          $a![1]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'getHealthConnectSettingsAction()Ljava/lang/String;') {
        final $r = _$impls[$p]!.getHealthConnectSettingsAction();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'getSdkStatus(Landroid/content/Context;Ljava/lang/String;)I') {
        final $r = _$impls[$p]!.getSdkStatus(
          $a![0]!.as(const $Context$Type(), releaseOriginal: true),
          $a![1]!.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d ==
          r'getOrCreate(Landroid/content/Context;Ljava/lang/String;)Landroidx/health/connect/client/HealthConnectClient;') {
        final $r = _$impls[$p]!.getOrCreate(
          $a![0]!.as(const $Context$Type(), releaseOriginal: true),
          $a![1]!.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'getHealthConnectManageDataIntent(Landroid/content/Context;Ljava/lang/String;)Landroid/content/Intent;') {
        final $r = _$impls[$p]!.getHealthConnectManageDataIntent(
          $a![0]!.as(const $Context$Type(), releaseOriginal: true),
          $a![1]!.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'getSdkStatus(Landroid/content/Context;)I') {
        final $r = _$impls[$p]!.getSdkStatus$1(
          $a![0]!.as(const $Context$Type(), releaseOriginal: true),
        );
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d ==
          r'getOrCreate(Landroid/content/Context;)Landroidx/health/connect/client/HealthConnectClient;') {
        final $r = _$impls[$p]!.getOrCreate$1(
          $a![0]!.as(const $Context$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'getHealthConnectManageDataIntent(Landroid/content/Context;)Landroid/content/Intent;') {
        final $r = _$impls[$p]!.getHealthConnectManageDataIntent$1(
          $a![0]!.as(const $Context$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $HealthConnectClient $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.health.connect.client.HealthConnectClient',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory HealthConnectClient.implement($HealthConnectClient $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return HealthConnectClient.fromReference($i.implementReference());
  }
}

abstract base mixin class $HealthConnectClient {
  factory $HealthConnectClient({
    required PermissionController Function() getPermissionController,
    required jni$_.JObject Function() getFeatures,
    required jni$_.JObject Function(
      jni$_.JList<jni$_.JObject?> list,
      jni$_.JObject continuation,
    )
    insertRecords,
    required jni$_.JObject Function(
      jni$_.JList<jni$_.JObject?> list,
      jni$_.JObject continuation,
    )
    updateRecords,
    required jni$_.JObject Function(
      jni$_.JObject kClass,
      jni$_.JList<jni$_.JString?> list,
      jni$_.JList<jni$_.JString?> list1,
      jni$_.JObject continuation,
    )
    deleteRecords,
    required jni$_.JObject Function(
      jni$_.JObject kClass,
      TimeRangeFilter timeRangeFilter,
      jni$_.JObject continuation,
    )
    deleteRecords$1,
    required jni$_.JObject Function(
      jni$_.JObject kClass,
      jni$_.JString string,
      jni$_.JObject continuation,
    )
    readRecord,
    required jni$_.JObject Function(
      jni$_.JObject readRecordsRequest,
      jni$_.JObject continuation,
    )
    readRecords,
    required jni$_.JObject Function(
      AggregateRequest aggregateRequest,
      jni$_.JObject continuation,
    )
    aggregate,
    required jni$_.JObject Function(
      jni$_.JObject aggregateGroupByDurationRequest,
      jni$_.JObject continuation,
    )
    aggregateGroupByDuration,
    required jni$_.JObject Function(
      jni$_.JObject aggregateGroupByPeriodRequest,
      jni$_.JObject continuation,
    )
    aggregateGroupByPeriod,
    required jni$_.JObject Function(
      jni$_.JObject changesTokenRequest,
      jni$_.JObject continuation,
    )
    getChangesToken,
    required jni$_.JObject Function(
      jni$_.JString string,
      jni$_.JObject continuation,
    )
    getChanges,
    required jni$_.JObject Function(
      jni$_.JList<jni$_.JObject?> list,
      jni$_.JObject continuation,
    )
    upsertMedicalResources,
    required jni$_.JObject Function(
      jni$_.JObject readMedicalResourcesRequest,
      jni$_.JObject continuation,
    )
    readMedicalResources,
    required jni$_.JObject Function(
      jni$_.JList<jni$_.JObject?> list,
      jni$_.JObject continuation,
    )
    readMedicalResources$1,
    required jni$_.JObject Function(
      jni$_.JList<jni$_.JObject?> list,
      jni$_.JObject continuation,
    )
    deleteMedicalResources,
    required jni$_.JObject Function(
      jni$_.JObject deleteMedicalResourcesRequest,
      jni$_.JObject continuation,
    )
    deleteMedicalResources$1,
    required jni$_.JObject Function(
      jni$_.JObject createMedicalDataSourceRequest,
      jni$_.JObject continuation,
    )
    createMedicalDataSource,
    required jni$_.JObject Function(
      jni$_.JString string,
      jni$_.JObject continuation,
    )
    deleteMedicalDataSourceWithData,
    required jni$_.JObject Function(
      jni$_.JObject getMedicalDataSourcesRequest,
      jni$_.JObject continuation,
    )
    getMedicalDataSources,
    required jni$_.JObject Function(
      jni$_.JList<jni$_.JString?> list,
      jni$_.JObject continuation,
    )
    getMedicalDataSources$1,
    required jni$_.JString Function() getHealthConnectSettingsAction,
    required int Function(Context context, jni$_.JString string) getSdkStatus,
    required HealthConnectClient Function(Context context, jni$_.JString string)
    getOrCreate,
    required jni$_.JObject Function(Context context, jni$_.JString string)
    getHealthConnectManageDataIntent,
    required int Function(Context context) getSdkStatus$1,
    required HealthConnectClient Function(Context context) getOrCreate$1,
    required jni$_.JObject Function(Context context)
    getHealthConnectManageDataIntent$1,
  }) = _$HealthConnectClient;

  PermissionController getPermissionController();
  jni$_.JObject getFeatures();
  jni$_.JObject insertRecords(
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JObject continuation,
  );
  jni$_.JObject updateRecords(
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JObject continuation,
  );
  jni$_.JObject deleteRecords(
    jni$_.JObject kClass,
    jni$_.JList<jni$_.JString?> list,
    jni$_.JList<jni$_.JString?> list1,
    jni$_.JObject continuation,
  );
  jni$_.JObject deleteRecords$1(
    jni$_.JObject kClass,
    TimeRangeFilter timeRangeFilter,
    jni$_.JObject continuation,
  );
  jni$_.JObject readRecord(
    jni$_.JObject kClass,
    jni$_.JString string,
    jni$_.JObject continuation,
  );
  jni$_.JObject readRecords(
    jni$_.JObject readRecordsRequest,
    jni$_.JObject continuation,
  );
  jni$_.JObject aggregate(
    AggregateRequest aggregateRequest,
    jni$_.JObject continuation,
  );
  jni$_.JObject aggregateGroupByDuration(
    jni$_.JObject aggregateGroupByDurationRequest,
    jni$_.JObject continuation,
  );
  jni$_.JObject aggregateGroupByPeriod(
    jni$_.JObject aggregateGroupByPeriodRequest,
    jni$_.JObject continuation,
  );
  jni$_.JObject getChangesToken(
    jni$_.JObject changesTokenRequest,
    jni$_.JObject continuation,
  );
  jni$_.JObject getChanges(jni$_.JString string, jni$_.JObject continuation);
  jni$_.JObject upsertMedicalResources(
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JObject continuation,
  );
  jni$_.JObject readMedicalResources(
    jni$_.JObject readMedicalResourcesRequest,
    jni$_.JObject continuation,
  );
  jni$_.JObject readMedicalResources$1(
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JObject continuation,
  );
  jni$_.JObject deleteMedicalResources(
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JObject continuation,
  );
  jni$_.JObject deleteMedicalResources$1(
    jni$_.JObject deleteMedicalResourcesRequest,
    jni$_.JObject continuation,
  );
  jni$_.JObject createMedicalDataSource(
    jni$_.JObject createMedicalDataSourceRequest,
    jni$_.JObject continuation,
  );
  jni$_.JObject deleteMedicalDataSourceWithData(
    jni$_.JString string,
    jni$_.JObject continuation,
  );
  jni$_.JObject getMedicalDataSources(
    jni$_.JObject getMedicalDataSourcesRequest,
    jni$_.JObject continuation,
  );
  jni$_.JObject getMedicalDataSources$1(
    jni$_.JList<jni$_.JString?> list,
    jni$_.JObject continuation,
  );
  jni$_.JString getHealthConnectSettingsAction();
  int getSdkStatus(Context context, jni$_.JString string);
  HealthConnectClient getOrCreate(Context context, jni$_.JString string);
  jni$_.JObject getHealthConnectManageDataIntent(
    Context context,
    jni$_.JString string,
  );
  int getSdkStatus$1(Context context);
  HealthConnectClient getOrCreate$1(Context context);
  jni$_.JObject getHealthConnectManageDataIntent$1(Context context);
}

final class _$HealthConnectClient with $HealthConnectClient {
  _$HealthConnectClient({
    required PermissionController Function() getPermissionController,
    required jni$_.JObject Function() getFeatures,
    required jni$_.JObject Function(
      jni$_.JList<jni$_.JObject?> list,
      jni$_.JObject continuation,
    )
    insertRecords,
    required jni$_.JObject Function(
      jni$_.JList<jni$_.JObject?> list,
      jni$_.JObject continuation,
    )
    updateRecords,
    required jni$_.JObject Function(
      jni$_.JObject kClass,
      jni$_.JList<jni$_.JString?> list,
      jni$_.JList<jni$_.JString?> list1,
      jni$_.JObject continuation,
    )
    deleteRecords,
    required jni$_.JObject Function(
      jni$_.JObject kClass,
      TimeRangeFilter timeRangeFilter,
      jni$_.JObject continuation,
    )
    deleteRecords$1,
    required jni$_.JObject Function(
      jni$_.JObject kClass,
      jni$_.JString string,
      jni$_.JObject continuation,
    )
    readRecord,
    required jni$_.JObject Function(
      jni$_.JObject readRecordsRequest,
      jni$_.JObject continuation,
    )
    readRecords,
    required jni$_.JObject Function(
      AggregateRequest aggregateRequest,
      jni$_.JObject continuation,
    )
    aggregate,
    required jni$_.JObject Function(
      jni$_.JObject aggregateGroupByDurationRequest,
      jni$_.JObject continuation,
    )
    aggregateGroupByDuration,
    required jni$_.JObject Function(
      jni$_.JObject aggregateGroupByPeriodRequest,
      jni$_.JObject continuation,
    )
    aggregateGroupByPeriod,
    required jni$_.JObject Function(
      jni$_.JObject changesTokenRequest,
      jni$_.JObject continuation,
    )
    getChangesToken,
    required jni$_.JObject Function(
      jni$_.JString string,
      jni$_.JObject continuation,
    )
    getChanges,
    required jni$_.JObject Function(
      jni$_.JList<jni$_.JObject?> list,
      jni$_.JObject continuation,
    )
    upsertMedicalResources,
    required jni$_.JObject Function(
      jni$_.JObject readMedicalResourcesRequest,
      jni$_.JObject continuation,
    )
    readMedicalResources,
    required jni$_.JObject Function(
      jni$_.JList<jni$_.JObject?> list,
      jni$_.JObject continuation,
    )
    readMedicalResources$1,
    required jni$_.JObject Function(
      jni$_.JList<jni$_.JObject?> list,
      jni$_.JObject continuation,
    )
    deleteMedicalResources,
    required jni$_.JObject Function(
      jni$_.JObject deleteMedicalResourcesRequest,
      jni$_.JObject continuation,
    )
    deleteMedicalResources$1,
    required jni$_.JObject Function(
      jni$_.JObject createMedicalDataSourceRequest,
      jni$_.JObject continuation,
    )
    createMedicalDataSource,
    required jni$_.JObject Function(
      jni$_.JString string,
      jni$_.JObject continuation,
    )
    deleteMedicalDataSourceWithData,
    required jni$_.JObject Function(
      jni$_.JObject getMedicalDataSourcesRequest,
      jni$_.JObject continuation,
    )
    getMedicalDataSources,
    required jni$_.JObject Function(
      jni$_.JList<jni$_.JString?> list,
      jni$_.JObject continuation,
    )
    getMedicalDataSources$1,
    required jni$_.JString Function() getHealthConnectSettingsAction,
    required int Function(Context context, jni$_.JString string) getSdkStatus,
    required HealthConnectClient Function(Context context, jni$_.JString string)
    getOrCreate,
    required jni$_.JObject Function(Context context, jni$_.JString string)
    getHealthConnectManageDataIntent,
    required int Function(Context context) getSdkStatus$1,
    required HealthConnectClient Function(Context context) getOrCreate$1,
    required jni$_.JObject Function(Context context)
    getHealthConnectManageDataIntent$1,
  }) : _getPermissionController = getPermissionController,
       _getFeatures = getFeatures,
       _insertRecords = insertRecords,
       _updateRecords = updateRecords,
       _deleteRecords = deleteRecords,
       _deleteRecords$1 = deleteRecords$1,
       _readRecord = readRecord,
       _readRecords = readRecords,
       _aggregate = aggregate,
       _aggregateGroupByDuration = aggregateGroupByDuration,
       _aggregateGroupByPeriod = aggregateGroupByPeriod,
       _getChangesToken = getChangesToken,
       _getChanges = getChanges,
       _upsertMedicalResources = upsertMedicalResources,
       _readMedicalResources = readMedicalResources,
       _readMedicalResources$1 = readMedicalResources$1,
       _deleteMedicalResources = deleteMedicalResources,
       _deleteMedicalResources$1 = deleteMedicalResources$1,
       _createMedicalDataSource = createMedicalDataSource,
       _deleteMedicalDataSourceWithData = deleteMedicalDataSourceWithData,
       _getMedicalDataSources = getMedicalDataSources,
       _getMedicalDataSources$1 = getMedicalDataSources$1,
       _getHealthConnectSettingsAction = getHealthConnectSettingsAction,
       _getSdkStatus = getSdkStatus,
       _getOrCreate = getOrCreate,
       _getHealthConnectManageDataIntent = getHealthConnectManageDataIntent,
       _getSdkStatus$1 = getSdkStatus$1,
       _getOrCreate$1 = getOrCreate$1,
       _getHealthConnectManageDataIntent$1 = getHealthConnectManageDataIntent$1;

  final PermissionController Function() _getPermissionController;
  final jni$_.JObject Function() _getFeatures;
  final jni$_.JObject Function(
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JObject continuation,
  )
  _insertRecords;
  final jni$_.JObject Function(
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JObject continuation,
  )
  _updateRecords;
  final jni$_.JObject Function(
    jni$_.JObject kClass,
    jni$_.JList<jni$_.JString?> list,
    jni$_.JList<jni$_.JString?> list1,
    jni$_.JObject continuation,
  )
  _deleteRecords;
  final jni$_.JObject Function(
    jni$_.JObject kClass,
    TimeRangeFilter timeRangeFilter,
    jni$_.JObject continuation,
  )
  _deleteRecords$1;
  final jni$_.JObject Function(
    jni$_.JObject kClass,
    jni$_.JString string,
    jni$_.JObject continuation,
  )
  _readRecord;
  final jni$_.JObject Function(
    jni$_.JObject readRecordsRequest,
    jni$_.JObject continuation,
  )
  _readRecords;
  final jni$_.JObject Function(
    AggregateRequest aggregateRequest,
    jni$_.JObject continuation,
  )
  _aggregate;
  final jni$_.JObject Function(
    jni$_.JObject aggregateGroupByDurationRequest,
    jni$_.JObject continuation,
  )
  _aggregateGroupByDuration;
  final jni$_.JObject Function(
    jni$_.JObject aggregateGroupByPeriodRequest,
    jni$_.JObject continuation,
  )
  _aggregateGroupByPeriod;
  final jni$_.JObject Function(
    jni$_.JObject changesTokenRequest,
    jni$_.JObject continuation,
  )
  _getChangesToken;
  final jni$_.JObject Function(jni$_.JString string, jni$_.JObject continuation)
  _getChanges;
  final jni$_.JObject Function(
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JObject continuation,
  )
  _upsertMedicalResources;
  final jni$_.JObject Function(
    jni$_.JObject readMedicalResourcesRequest,
    jni$_.JObject continuation,
  )
  _readMedicalResources;
  final jni$_.JObject Function(
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JObject continuation,
  )
  _readMedicalResources$1;
  final jni$_.JObject Function(
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JObject continuation,
  )
  _deleteMedicalResources;
  final jni$_.JObject Function(
    jni$_.JObject deleteMedicalResourcesRequest,
    jni$_.JObject continuation,
  )
  _deleteMedicalResources$1;
  final jni$_.JObject Function(
    jni$_.JObject createMedicalDataSourceRequest,
    jni$_.JObject continuation,
  )
  _createMedicalDataSource;
  final jni$_.JObject Function(jni$_.JString string, jni$_.JObject continuation)
  _deleteMedicalDataSourceWithData;
  final jni$_.JObject Function(
    jni$_.JObject getMedicalDataSourcesRequest,
    jni$_.JObject continuation,
  )
  _getMedicalDataSources;
  final jni$_.JObject Function(
    jni$_.JList<jni$_.JString?> list,
    jni$_.JObject continuation,
  )
  _getMedicalDataSources$1;
  final jni$_.JString Function() _getHealthConnectSettingsAction;
  final int Function(Context context, jni$_.JString string) _getSdkStatus;
  final HealthConnectClient Function(Context context, jni$_.JString string)
  _getOrCreate;
  final jni$_.JObject Function(Context context, jni$_.JString string)
  _getHealthConnectManageDataIntent;
  final int Function(Context context) _getSdkStatus$1;
  final HealthConnectClient Function(Context context) _getOrCreate$1;
  final jni$_.JObject Function(Context context)
  _getHealthConnectManageDataIntent$1;

  PermissionController getPermissionController() {
    return _getPermissionController();
  }

  jni$_.JObject getFeatures() {
    return _getFeatures();
  }

  jni$_.JObject insertRecords(
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JObject continuation,
  ) {
    return _insertRecords(list, continuation);
  }

  jni$_.JObject updateRecords(
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JObject continuation,
  ) {
    return _updateRecords(list, continuation);
  }

  jni$_.JObject deleteRecords(
    jni$_.JObject kClass,
    jni$_.JList<jni$_.JString?> list,
    jni$_.JList<jni$_.JString?> list1,
    jni$_.JObject continuation,
  ) {
    return _deleteRecords(kClass, list, list1, continuation);
  }

  jni$_.JObject deleteRecords$1(
    jni$_.JObject kClass,
    TimeRangeFilter timeRangeFilter,
    jni$_.JObject continuation,
  ) {
    return _deleteRecords$1(kClass, timeRangeFilter, continuation);
  }

  jni$_.JObject readRecord(
    jni$_.JObject kClass,
    jni$_.JString string,
    jni$_.JObject continuation,
  ) {
    return _readRecord(kClass, string, continuation);
  }

  jni$_.JObject readRecords(
    jni$_.JObject readRecordsRequest,
    jni$_.JObject continuation,
  ) {
    return _readRecords(readRecordsRequest, continuation);
  }

  jni$_.JObject aggregate(
    AggregateRequest aggregateRequest,
    jni$_.JObject continuation,
  ) {
    return _aggregate(aggregateRequest, continuation);
  }

  jni$_.JObject aggregateGroupByDuration(
    jni$_.JObject aggregateGroupByDurationRequest,
    jni$_.JObject continuation,
  ) {
    return _aggregateGroupByDuration(
      aggregateGroupByDurationRequest,
      continuation,
    );
  }

  jni$_.JObject aggregateGroupByPeriod(
    jni$_.JObject aggregateGroupByPeriodRequest,
    jni$_.JObject continuation,
  ) {
    return _aggregateGroupByPeriod(aggregateGroupByPeriodRequest, continuation);
  }

  jni$_.JObject getChangesToken(
    jni$_.JObject changesTokenRequest,
    jni$_.JObject continuation,
  ) {
    return _getChangesToken(changesTokenRequest, continuation);
  }

  jni$_.JObject getChanges(jni$_.JString string, jni$_.JObject continuation) {
    return _getChanges(string, continuation);
  }

  jni$_.JObject upsertMedicalResources(
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JObject continuation,
  ) {
    return _upsertMedicalResources(list, continuation);
  }

  jni$_.JObject readMedicalResources(
    jni$_.JObject readMedicalResourcesRequest,
    jni$_.JObject continuation,
  ) {
    return _readMedicalResources(readMedicalResourcesRequest, continuation);
  }

  jni$_.JObject readMedicalResources$1(
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JObject continuation,
  ) {
    return _readMedicalResources$1(list, continuation);
  }

  jni$_.JObject deleteMedicalResources(
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JObject continuation,
  ) {
    return _deleteMedicalResources(list, continuation);
  }

  jni$_.JObject deleteMedicalResources$1(
    jni$_.JObject deleteMedicalResourcesRequest,
    jni$_.JObject continuation,
  ) {
    return _deleteMedicalResources$1(
      deleteMedicalResourcesRequest,
      continuation,
    );
  }

  jni$_.JObject createMedicalDataSource(
    jni$_.JObject createMedicalDataSourceRequest,
    jni$_.JObject continuation,
  ) {
    return _createMedicalDataSource(
      createMedicalDataSourceRequest,
      continuation,
    );
  }

  jni$_.JObject deleteMedicalDataSourceWithData(
    jni$_.JString string,
    jni$_.JObject continuation,
  ) {
    return _deleteMedicalDataSourceWithData(string, continuation);
  }

  jni$_.JObject getMedicalDataSources(
    jni$_.JObject getMedicalDataSourcesRequest,
    jni$_.JObject continuation,
  ) {
    return _getMedicalDataSources(getMedicalDataSourcesRequest, continuation);
  }

  jni$_.JObject getMedicalDataSources$1(
    jni$_.JList<jni$_.JString?> list,
    jni$_.JObject continuation,
  ) {
    return _getMedicalDataSources$1(list, continuation);
  }

  jni$_.JString getHealthConnectSettingsAction() {
    return _getHealthConnectSettingsAction();
  }

  int getSdkStatus(Context context, jni$_.JString string) {
    return _getSdkStatus(context, string);
  }

  HealthConnectClient getOrCreate(Context context, jni$_.JString string) {
    return _getOrCreate(context, string);
  }

  jni$_.JObject getHealthConnectManageDataIntent(
    Context context,
    jni$_.JString string,
  ) {
    return _getHealthConnectManageDataIntent(context, string);
  }

  int getSdkStatus$1(Context context) {
    return _getSdkStatus$1(context);
  }

  HealthConnectClient getOrCreate$1(Context context) {
    return _getOrCreate$1(context);
  }

  jni$_.JObject getHealthConnectManageDataIntent$1(Context context) {
    return _getHealthConnectManageDataIntent$1(context);
  }
}

final class $HealthConnectClient$NullableType
    extends jni$_.JObjType<HealthConnectClient?> {
  @jni$_.internal
  const $HealthConnectClient$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/HealthConnectClient;';

  @jni$_.internal
  @core$_.override
  HealthConnectClient? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : HealthConnectClient.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<HealthConnectClient?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($HealthConnectClient$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($HealthConnectClient$NullableType) &&
        other is $HealthConnectClient$NullableType;
  }
}

final class $HealthConnectClient$Type
    extends jni$_.JObjType<HealthConnectClient> {
  @jni$_.internal
  const $HealthConnectClient$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/HealthConnectClient;';

  @jni$_.internal
  @core$_.override
  HealthConnectClient fromReference(jni$_.JReference reference) =>
      HealthConnectClient.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<HealthConnectClient?> get nullableType =>
      const $HealthConnectClient$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($HealthConnectClient$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($HealthConnectClient$Type) &&
        other is $HealthConnectClient$Type;
  }
}

/// from: `androidx.health.connect.client.PermissionController$Companion`
class PermissionController$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<PermissionController$Companion> $type;

  @jni$_.internal
  PermissionController$Companion.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/health/connect/client/PermissionController$Companion',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $PermissionController$Companion$NullableType();
  static const type = $PermissionController$Companion$Type();
  static final _id_createRequestPermissionResultContract = _class.instanceMethodId(
    r'createRequestPermissionResultContract',
    r'(Ljava/lang/String;)Landroidx/activity/result/contract/ActivityResultContract;',
  );

  static final _createRequestPermissionResultContract =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final androidx.activity.result.contract.ActivityResultContract createRequestPermissionResultContract(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject createRequestPermissionResultContract(jni$_.JString string) {
    final _$string = string.reference;
    return _createRequestPermissionResultContract(
      reference.pointer,
      _id_createRequestPermissionResultContract as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_createRequestPermissionResultContract$1 = _class
      .instanceMethodId(
        r'createRequestPermissionResultContract',
        r'()Landroidx/activity/result/contract/ActivityResultContract;',
      );

  static final _createRequestPermissionResultContract$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final androidx.activity.result.contract.ActivityResultContract createRequestPermissionResultContract()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject createRequestPermissionResultContract$1() {
    return _createRequestPermissionResultContract$1(
      reference.pointer,
      _id_createRequestPermissionResultContract$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
  }
}

final class $PermissionController$Companion$NullableType
    extends jni$_.JObjType<PermissionController$Companion?> {
  @jni$_.internal
  const $PermissionController$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/PermissionController$Companion;';

  @jni$_.internal
  @core$_.override
  PermissionController$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : PermissionController$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PermissionController$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($PermissionController$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($PermissionController$Companion$NullableType) &&
        other is $PermissionController$Companion$NullableType;
  }
}

final class $PermissionController$Companion$Type
    extends jni$_.JObjType<PermissionController$Companion> {
  @jni$_.internal
  const $PermissionController$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/PermissionController$Companion;';

  @jni$_.internal
  @core$_.override
  PermissionController$Companion fromReference(jni$_.JReference reference) =>
      PermissionController$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PermissionController$Companion?> get nullableType =>
      const $PermissionController$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($PermissionController$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PermissionController$Companion$Type) &&
        other is $PermissionController$Companion$Type;
  }
}

/// from: `androidx.health.connect.client.PermissionController`
class PermissionController extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<PermissionController> $type;

  @jni$_.internal
  PermissionController.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/health/connect/client/PermissionController',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $PermissionController$NullableType();
  static const type = $PermissionController$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Landroidx/health/connect/client/PermissionController$Companion;',
  );

  /// from: `static public final androidx.health.connect.client.PermissionController$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static PermissionController$Companion get Companion =>
      _id_Companion.get(_class, const $PermissionController$Companion$Type());

  static final _id_getGrantedPermissions = _class.instanceMethodId(
    r'getGrantedPermissions',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _getGrantedPermissions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.lang.Object getGrantedPermissions(kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JSet<jni$_.JString>> getGrantedPermissions() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _getGrantedPermissions(
      reference.pointer,
      _id_getGrantedPermissions as jni$_.JMethodIDPtr,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress(await $p.first)),
      );
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.JObjectType(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as(
      const jni$_.JSetType<jni$_.JString>(jni$_.JStringType()),
      releaseOriginal: true,
    );
  }

  static final _id_revokeAllPermissions = _class.instanceMethodId(
    r'revokeAllPermissions',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _revokeAllPermissions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.lang.Object revokeAllPermissions(kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> revokeAllPermissions() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _revokeAllPermissions(
      reference.pointer,
      _id_revokeAllPermissions as jni$_.JMethodIDPtr,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress(await $p.first)),
      );
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.JObjectType(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as(const jni$_.JObjectType(), releaseOriginal: true);
  }

  static final _id_createRequestPermissionResultContract = _class.staticMethodId(
    r'createRequestPermissionResultContract',
    r'(Ljava/lang/String;)Landroidx/activity/result/contract/ActivityResultContract;',
  );

  static final _createRequestPermissionResultContract =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public androidx.activity.result.contract.ActivityResultContract createRequestPermissionResultContract(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject createRequestPermissionResultContract(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _createRequestPermissionResultContract(
      _class.reference.pointer,
      _id_createRequestPermissionResultContract as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_createRequestPermissionResultContract$1 = _class
      .staticMethodId(
        r'createRequestPermissionResultContract',
        r'()Landroidx/activity/result/contract/ActivityResultContract;',
      );

  static final _createRequestPermissionResultContract$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public androidx.activity.result.contract.ActivityResultContract createRequestPermissionResultContract()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject createRequestPermissionResultContract$1() {
    return _createRequestPermissionResultContract$1(
      _class.reference.pointer,
      _id_createRequestPermissionResultContract$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $PermissionController> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'getGrantedPermissions(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.getGrantedPermissions(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'revokeAllPermissions(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.revokeAllPermissions(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'createRequestPermissionResultContract(Ljava/lang/String;)Landroidx/activity/result/contract/ActivityResultContract;') {
        final $r = _$impls[$p]!.createRequestPermissionResultContract(
          $a![0]!.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'createRequestPermissionResultContract()Landroidx/activity/result/contract/ActivityResultContract;') {
        final $r = _$impls[$p]!.createRequestPermissionResultContract$1();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $PermissionController $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.health.connect.client.PermissionController',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory PermissionController.implement($PermissionController $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return PermissionController.fromReference($i.implementReference());
  }
}

abstract base mixin class $PermissionController {
  factory $PermissionController({
    required jni$_.JObject Function(jni$_.JObject continuation)
    getGrantedPermissions,
    required jni$_.JObject Function(jni$_.JObject continuation)
    revokeAllPermissions,
    required jni$_.JObject Function(jni$_.JString string)
    createRequestPermissionResultContract,
    required jni$_.JObject Function() createRequestPermissionResultContract$1,
  }) = _$PermissionController;

  jni$_.JObject getGrantedPermissions(jni$_.JObject continuation);
  jni$_.JObject revokeAllPermissions(jni$_.JObject continuation);
  jni$_.JObject createRequestPermissionResultContract(jni$_.JString string);
  jni$_.JObject createRequestPermissionResultContract$1();
}

final class _$PermissionController with $PermissionController {
  _$PermissionController({
    required jni$_.JObject Function(jni$_.JObject continuation)
    getGrantedPermissions,
    required jni$_.JObject Function(jni$_.JObject continuation)
    revokeAllPermissions,
    required jni$_.JObject Function(jni$_.JString string)
    createRequestPermissionResultContract,
    required jni$_.JObject Function() createRequestPermissionResultContract$1,
  }) : _getGrantedPermissions = getGrantedPermissions,
       _revokeAllPermissions = revokeAllPermissions,
       _createRequestPermissionResultContract =
           createRequestPermissionResultContract,
       _createRequestPermissionResultContract$1 =
           createRequestPermissionResultContract$1;

  final jni$_.JObject Function(jni$_.JObject continuation)
  _getGrantedPermissions;
  final jni$_.JObject Function(jni$_.JObject continuation)
  _revokeAllPermissions;
  final jni$_.JObject Function(jni$_.JString string)
  _createRequestPermissionResultContract;
  final jni$_.JObject Function() _createRequestPermissionResultContract$1;

  jni$_.JObject getGrantedPermissions(jni$_.JObject continuation) {
    return _getGrantedPermissions(continuation);
  }

  jni$_.JObject revokeAllPermissions(jni$_.JObject continuation) {
    return _revokeAllPermissions(continuation);
  }

  jni$_.JObject createRequestPermissionResultContract(jni$_.JString string) {
    return _createRequestPermissionResultContract(string);
  }

  jni$_.JObject createRequestPermissionResultContract$1() {
    return _createRequestPermissionResultContract$1();
  }
}

final class $PermissionController$NullableType
    extends jni$_.JObjType<PermissionController?> {
  @jni$_.internal
  const $PermissionController$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/PermissionController;';

  @jni$_.internal
  @core$_.override
  PermissionController? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : PermissionController.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PermissionController?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($PermissionController$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PermissionController$NullableType) &&
        other is $PermissionController$NullableType;
  }
}

final class $PermissionController$Type
    extends jni$_.JObjType<PermissionController> {
  @jni$_.internal
  const $PermissionController$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/PermissionController;';

  @jni$_.internal
  @core$_.override
  PermissionController fromReference(jni$_.JReference reference) =>
      PermissionController.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PermissionController?> get nullableType =>
      const $PermissionController$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($PermissionController$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PermissionController$Type) &&
        other is $PermissionController$Type;
  }
}

/// from: `android.content.Context$BindServiceFlags`
class Context$BindServiceFlags extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Context$BindServiceFlags> $type;

  @jni$_.internal
  Context$BindServiceFlags.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/content/Context$BindServiceFlags',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Context$BindServiceFlags$NullableType();
  static const type = $Context$BindServiceFlags$Type();
  static final _id_of = _class.staticMethodId(
    r'of',
    r'(J)Landroid/content/Context$BindServiceFlags;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public android.content.Context$BindServiceFlags of(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static Context$BindServiceFlags? of(int j) {
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      j,
    ).object<Context$BindServiceFlags?>(
      const $Context$BindServiceFlags$NullableType(),
    );
  }
}

final class $Context$BindServiceFlags$NullableType
    extends jni$_.JObjType<Context$BindServiceFlags?> {
  @jni$_.internal
  const $Context$BindServiceFlags$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/content/Context$BindServiceFlags;';

  @jni$_.internal
  @core$_.override
  Context$BindServiceFlags? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Context$BindServiceFlags.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Context$BindServiceFlags?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Context$BindServiceFlags$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Context$BindServiceFlags$NullableType) &&
        other is $Context$BindServiceFlags$NullableType;
  }
}

final class $Context$BindServiceFlags$Type
    extends jni$_.JObjType<Context$BindServiceFlags> {
  @jni$_.internal
  const $Context$BindServiceFlags$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/content/Context$BindServiceFlags;';

  @jni$_.internal
  @core$_.override
  Context$BindServiceFlags fromReference(jni$_.JReference reference) =>
      Context$BindServiceFlags.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Context$BindServiceFlags?> get nullableType =>
      const $Context$BindServiceFlags$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Context$BindServiceFlags$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Context$BindServiceFlags$Type) &&
        other is $Context$BindServiceFlags$Type;
  }
}

/// from: `android.content.Context`
class Context extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Context> $type;

  @jni$_.internal
  Context.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/content/Context');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Context$NullableType();
  static const type = $Context$Type();
  static final _id_ACCESSIBILITY_SERVICE = _class.staticFieldId(
    r'ACCESSIBILITY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ACCESSIBILITY_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ACCESSIBILITY_SERVICE =>
      _id_ACCESSIBILITY_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_ACCOUNT_SERVICE = _class.staticFieldId(
    r'ACCOUNT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ACCOUNT_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ACCOUNT_SERVICE =>
      _id_ACCOUNT_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_ACTIVITY_SERVICE = _class.staticFieldId(
    r'ACTIVITY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ACTIVITY_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ACTIVITY_SERVICE =>
      _id_ACTIVITY_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_ADVANCED_PROTECTION_SERVICE = _class.staticFieldId(
    r'ADVANCED_PROTECTION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ADVANCED_PROTECTION_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ADVANCED_PROTECTION_SERVICE =>
      _id_ADVANCED_PROTECTION_SERVICE.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_ALARM_SERVICE = _class.staticFieldId(
    r'ALARM_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ALARM_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ALARM_SERVICE =>
      _id_ALARM_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_APPWIDGET_SERVICE = _class.staticFieldId(
    r'APPWIDGET_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String APPWIDGET_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get APPWIDGET_SERVICE =>
      _id_APPWIDGET_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_APP_FUNCTION_SERVICE = _class.staticFieldId(
    r'APP_FUNCTION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String APP_FUNCTION_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get APP_FUNCTION_SERVICE =>
      _id_APP_FUNCTION_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_APP_OPS_SERVICE = _class.staticFieldId(
    r'APP_OPS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String APP_OPS_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get APP_OPS_SERVICE =>
      _id_APP_OPS_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_APP_SEARCH_SERVICE = _class.staticFieldId(
    r'APP_SEARCH_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String APP_SEARCH_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get APP_SEARCH_SERVICE =>
      _id_APP_SEARCH_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_AUDIO_SERVICE = _class.staticFieldId(
    r'AUDIO_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String AUDIO_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get AUDIO_SERVICE =>
      _id_AUDIO_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_BATTERY_SERVICE = _class.staticFieldId(
    r'BATTERY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BATTERY_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get BATTERY_SERVICE =>
      _id_BATTERY_SERVICE.get(_class, const jni$_.JStringNullableType());

  /// from: `static public final int BIND_ABOVE_CLIENT`
  static const BIND_ABOVE_CLIENT = 8;

  /// from: `static public final int BIND_ADJUST_WITH_ACTIVITY`
  static const BIND_ADJUST_WITH_ACTIVITY = 128;

  /// from: `static public final int BIND_ALLOW_ACTIVITY_STARTS`
  static const BIND_ALLOW_ACTIVITY_STARTS = 512;

  /// from: `static public final int BIND_ALLOW_OOM_MANAGEMENT`
  static const BIND_ALLOW_OOM_MANAGEMENT = 16;

  /// from: `static public final int BIND_AUTO_CREATE`
  static const BIND_AUTO_CREATE = 1;

  /// from: `static public final int BIND_DEBUG_UNBIND`
  static const BIND_DEBUG_UNBIND = 2;

  /// from: `static public final int BIND_EXTERNAL_SERVICE`
  static const BIND_EXTERNAL_SERVICE = -2147483648;

  /// from: `static public final long BIND_EXTERNAL_SERVICE_LONG`
  static const BIND_EXTERNAL_SERVICE_LONG = 4611686018427387904;

  /// from: `static public final int BIND_IMPORTANT`
  static const BIND_IMPORTANT = 64;

  /// from: `static public final int BIND_INCLUDE_CAPABILITIES`
  static const BIND_INCLUDE_CAPABILITIES = 4096;

  /// from: `static public final int BIND_NOT_FOREGROUND`
  static const BIND_NOT_FOREGROUND = 4;

  /// from: `static public final int BIND_NOT_PERCEPTIBLE`
  static const BIND_NOT_PERCEPTIBLE = 256;

  /// from: `static public final int BIND_PACKAGE_ISOLATED_PROCESS`
  static const BIND_PACKAGE_ISOLATED_PROCESS = 16384;

  /// from: `static public final int BIND_SHARED_ISOLATED_PROCESS`
  static const BIND_SHARED_ISOLATED_PROCESS = 8192;

  /// from: `static public final int BIND_WAIVE_PRIORITY`
  static const BIND_WAIVE_PRIORITY = 32;
  static final _id_BIOMETRIC_SERVICE = _class.staticFieldId(
    r'BIOMETRIC_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BIOMETRIC_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get BIOMETRIC_SERVICE =>
      _id_BIOMETRIC_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_BLOB_STORE_SERVICE = _class.staticFieldId(
    r'BLOB_STORE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BLOB_STORE_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get BLOB_STORE_SERVICE =>
      _id_BLOB_STORE_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_BLUETOOTH_SERVICE = _class.staticFieldId(
    r'BLUETOOTH_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BLUETOOTH_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get BLUETOOTH_SERVICE =>
      _id_BLUETOOTH_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_BUGREPORT_SERVICE = _class.staticFieldId(
    r'BUGREPORT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BUGREPORT_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get BUGREPORT_SERVICE =>
      _id_BUGREPORT_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_CAMERA_SERVICE = _class.staticFieldId(
    r'CAMERA_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CAMERA_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CAMERA_SERVICE =>
      _id_CAMERA_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_CAPTIONING_SERVICE = _class.staticFieldId(
    r'CAPTIONING_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CAPTIONING_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CAPTIONING_SERVICE =>
      _id_CAPTIONING_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_CARRIER_CONFIG_SERVICE = _class.staticFieldId(
    r'CARRIER_CONFIG_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CARRIER_CONFIG_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CARRIER_CONFIG_SERVICE =>
      _id_CARRIER_CONFIG_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_CLIPBOARD_SERVICE = _class.staticFieldId(
    r'CLIPBOARD_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CLIPBOARD_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CLIPBOARD_SERVICE =>
      _id_CLIPBOARD_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_COMPANION_DEVICE_SERVICE = _class.staticFieldId(
    r'COMPANION_DEVICE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String COMPANION_DEVICE_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get COMPANION_DEVICE_SERVICE =>
      _id_COMPANION_DEVICE_SERVICE.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_CONNECTIVITY_DIAGNOSTICS_SERVICE = _class.staticFieldId(
    r'CONNECTIVITY_DIAGNOSTICS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CONNECTIVITY_DIAGNOSTICS_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CONNECTIVITY_DIAGNOSTICS_SERVICE =>
      _id_CONNECTIVITY_DIAGNOSTICS_SERVICE.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_CONNECTIVITY_SERVICE = _class.staticFieldId(
    r'CONNECTIVITY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CONNECTIVITY_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CONNECTIVITY_SERVICE =>
      _id_CONNECTIVITY_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_CONSUMER_IR_SERVICE = _class.staticFieldId(
    r'CONSUMER_IR_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CONSUMER_IR_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CONSUMER_IR_SERVICE =>
      _id_CONSUMER_IR_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_CONTACT_KEYS_SERVICE = _class.staticFieldId(
    r'CONTACT_KEYS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CONTACT_KEYS_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CONTACT_KEYS_SERVICE =>
      _id_CONTACT_KEYS_SERVICE.get(_class, const jni$_.JStringNullableType());

  /// from: `static public final int CONTEXT_IGNORE_SECURITY`
  static const CONTEXT_IGNORE_SECURITY = 2;

  /// from: `static public final int CONTEXT_INCLUDE_CODE`
  static const CONTEXT_INCLUDE_CODE = 1;

  /// from: `static public final int CONTEXT_RESTRICTED`
  static const CONTEXT_RESTRICTED = 4;
  static final _id_CREDENTIAL_SERVICE = _class.staticFieldId(
    r'CREDENTIAL_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CREDENTIAL_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CREDENTIAL_SERVICE =>
      _id_CREDENTIAL_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_CROSS_PROFILE_APPS_SERVICE = _class.staticFieldId(
    r'CROSS_PROFILE_APPS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CROSS_PROFILE_APPS_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CROSS_PROFILE_APPS_SERVICE =>
      _id_CROSS_PROFILE_APPS_SERVICE.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  /// from: `static public final int DEVICE_ID_DEFAULT`
  static const DEVICE_ID_DEFAULT = 0;

  /// from: `static public final int DEVICE_ID_INVALID`
  static const DEVICE_ID_INVALID = -1;
  static final _id_DEVICE_LOCK_SERVICE = _class.staticFieldId(
    r'DEVICE_LOCK_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DEVICE_LOCK_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DEVICE_LOCK_SERVICE =>
      _id_DEVICE_LOCK_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_DEVICE_POLICY_SERVICE = _class.staticFieldId(
    r'DEVICE_POLICY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DEVICE_POLICY_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DEVICE_POLICY_SERVICE =>
      _id_DEVICE_POLICY_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_DISPLAY_HASH_SERVICE = _class.staticFieldId(
    r'DISPLAY_HASH_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DISPLAY_HASH_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DISPLAY_HASH_SERVICE =>
      _id_DISPLAY_HASH_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_DISPLAY_SERVICE = _class.staticFieldId(
    r'DISPLAY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DISPLAY_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DISPLAY_SERVICE =>
      _id_DISPLAY_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_DOMAIN_VERIFICATION_SERVICE = _class.staticFieldId(
    r'DOMAIN_VERIFICATION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DOMAIN_VERIFICATION_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DOMAIN_VERIFICATION_SERVICE =>
      _id_DOMAIN_VERIFICATION_SERVICE.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_DOWNLOAD_SERVICE = _class.staticFieldId(
    r'DOWNLOAD_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DOWNLOAD_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DOWNLOAD_SERVICE =>
      _id_DOWNLOAD_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_DROPBOX_SERVICE = _class.staticFieldId(
    r'DROPBOX_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DROPBOX_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DROPBOX_SERVICE =>
      _id_DROPBOX_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_EUICC_SERVICE = _class.staticFieldId(
    r'EUICC_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EUICC_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EUICC_SERVICE =>
      _id_EUICC_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_FILE_INTEGRITY_SERVICE = _class.staticFieldId(
    r'FILE_INTEGRITY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String FILE_INTEGRITY_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get FILE_INTEGRITY_SERVICE =>
      _id_FILE_INTEGRITY_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_FINGERPRINT_SERVICE = _class.staticFieldId(
    r'FINGERPRINT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String FINGERPRINT_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get FINGERPRINT_SERVICE =>
      _id_FINGERPRINT_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_GAME_SERVICE = _class.staticFieldId(
    r'GAME_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String GAME_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get GAME_SERVICE =>
      _id_GAME_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_GRAMMATICAL_INFLECTION_SERVICE = _class.staticFieldId(
    r'GRAMMATICAL_INFLECTION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String GRAMMATICAL_INFLECTION_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get GRAMMATICAL_INFLECTION_SERVICE =>
      _id_GRAMMATICAL_INFLECTION_SERVICE.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_HARDWARE_PROPERTIES_SERVICE = _class.staticFieldId(
    r'HARDWARE_PROPERTIES_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String HARDWARE_PROPERTIES_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get HARDWARE_PROPERTIES_SERVICE =>
      _id_HARDWARE_PROPERTIES_SERVICE.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_HEALTHCONNECT_SERVICE = _class.staticFieldId(
    r'HEALTHCONNECT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String HEALTHCONNECT_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get HEALTHCONNECT_SERVICE =>
      _id_HEALTHCONNECT_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_INPUT_METHOD_SERVICE = _class.staticFieldId(
    r'INPUT_METHOD_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String INPUT_METHOD_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get INPUT_METHOD_SERVICE =>
      _id_INPUT_METHOD_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_INPUT_SERVICE = _class.staticFieldId(
    r'INPUT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String INPUT_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get INPUT_SERVICE =>
      _id_INPUT_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_IPSEC_SERVICE = _class.staticFieldId(
    r'IPSEC_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String IPSEC_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get IPSEC_SERVICE =>
      _id_IPSEC_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_JOB_SCHEDULER_SERVICE = _class.staticFieldId(
    r'JOB_SCHEDULER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String JOB_SCHEDULER_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get JOB_SCHEDULER_SERVICE =>
      _id_JOB_SCHEDULER_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_KEYGUARD_SERVICE = _class.staticFieldId(
    r'KEYGUARD_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String KEYGUARD_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get KEYGUARD_SERVICE =>
      _id_KEYGUARD_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_KEYSTORE_SERVICE = _class.staticFieldId(
    r'KEYSTORE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String KEYSTORE_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get KEYSTORE_SERVICE =>
      _id_KEYSTORE_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_LAUNCHER_APPS_SERVICE = _class.staticFieldId(
    r'LAUNCHER_APPS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LAUNCHER_APPS_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get LAUNCHER_APPS_SERVICE =>
      _id_LAUNCHER_APPS_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_LAYOUT_INFLATER_SERVICE = _class.staticFieldId(
    r'LAYOUT_INFLATER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LAYOUT_INFLATER_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get LAYOUT_INFLATER_SERVICE =>
      _id_LAYOUT_INFLATER_SERVICE.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_LOCALE_SERVICE = _class.staticFieldId(
    r'LOCALE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LOCALE_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get LOCALE_SERVICE =>
      _id_LOCALE_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_LOCATION_SERVICE = _class.staticFieldId(
    r'LOCATION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String LOCATION_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get LOCATION_SERVICE =>
      _id_LOCATION_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_MEDIA_COMMUNICATION_SERVICE = _class.staticFieldId(
    r'MEDIA_COMMUNICATION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MEDIA_COMMUNICATION_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get MEDIA_COMMUNICATION_SERVICE =>
      _id_MEDIA_COMMUNICATION_SERVICE.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_MEDIA_METRICS_SERVICE = _class.staticFieldId(
    r'MEDIA_METRICS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MEDIA_METRICS_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get MEDIA_METRICS_SERVICE =>
      _id_MEDIA_METRICS_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_MEDIA_PROJECTION_SERVICE = _class.staticFieldId(
    r'MEDIA_PROJECTION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MEDIA_PROJECTION_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get MEDIA_PROJECTION_SERVICE =>
      _id_MEDIA_PROJECTION_SERVICE.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_MEDIA_QUALITY_SERVICE = _class.staticFieldId(
    r'MEDIA_QUALITY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MEDIA_QUALITY_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get MEDIA_QUALITY_SERVICE =>
      _id_MEDIA_QUALITY_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_MEDIA_ROUTER_SERVICE = _class.staticFieldId(
    r'MEDIA_ROUTER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MEDIA_ROUTER_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get MEDIA_ROUTER_SERVICE =>
      _id_MEDIA_ROUTER_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_MEDIA_SESSION_SERVICE = _class.staticFieldId(
    r'MEDIA_SESSION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MEDIA_SESSION_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get MEDIA_SESSION_SERVICE =>
      _id_MEDIA_SESSION_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_MIDI_SERVICE = _class.staticFieldId(
    r'MIDI_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MIDI_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get MIDI_SERVICE =>
      _id_MIDI_SERVICE.get(_class, const jni$_.JStringNullableType());

  /// from: `static public final int MODE_APPEND`
  static const MODE_APPEND = 32768;

  /// from: `static public final int MODE_ENABLE_WRITE_AHEAD_LOGGING`
  static const MODE_ENABLE_WRITE_AHEAD_LOGGING = 8;

  /// from: `static public final int MODE_MULTI_PROCESS`
  static const MODE_MULTI_PROCESS = 4;

  /// from: `static public final int MODE_NO_LOCALIZED_COLLATORS`
  static const MODE_NO_LOCALIZED_COLLATORS = 16;

  /// from: `static public final int MODE_PRIVATE`
  static const MODE_PRIVATE = 0;

  /// from: `static public final int MODE_WORLD_READABLE`
  static const MODE_WORLD_READABLE = 1;

  /// from: `static public final int MODE_WORLD_WRITEABLE`
  static const MODE_WORLD_WRITEABLE = 2;
  static final _id_NETWORK_STATS_SERVICE = _class.staticFieldId(
    r'NETWORK_STATS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String NETWORK_STATS_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get NETWORK_STATS_SERVICE =>
      _id_NETWORK_STATS_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_NFC_SERVICE = _class.staticFieldId(
    r'NFC_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String NFC_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get NFC_SERVICE =>
      _id_NFC_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_NOTIFICATION_SERVICE = _class.staticFieldId(
    r'NOTIFICATION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String NOTIFICATION_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get NOTIFICATION_SERVICE =>
      _id_NOTIFICATION_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_NSD_SERVICE = _class.staticFieldId(
    r'NSD_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String NSD_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get NSD_SERVICE =>
      _id_NSD_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_OVERLAY_SERVICE = _class.staticFieldId(
    r'OVERLAY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String OVERLAY_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get OVERLAY_SERVICE =>
      _id_OVERLAY_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_PEOPLE_SERVICE = _class.staticFieldId(
    r'PEOPLE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String PEOPLE_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get PEOPLE_SERVICE =>
      _id_PEOPLE_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_PERFORMANCE_HINT_SERVICE = _class.staticFieldId(
    r'PERFORMANCE_HINT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String PERFORMANCE_HINT_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get PERFORMANCE_HINT_SERVICE =>
      _id_PERFORMANCE_HINT_SERVICE.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_PERSISTENT_DATA_BLOCK_SERVICE = _class.staticFieldId(
    r'PERSISTENT_DATA_BLOCK_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String PERSISTENT_DATA_BLOCK_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get PERSISTENT_DATA_BLOCK_SERVICE =>
      _id_PERSISTENT_DATA_BLOCK_SERVICE.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_POWER_SERVICE = _class.staticFieldId(
    r'POWER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String POWER_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get POWER_SERVICE =>
      _id_POWER_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_PRINT_SERVICE = _class.staticFieldId(
    r'PRINT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String PRINT_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get PRINT_SERVICE =>
      _id_PRINT_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_PROFILING_SERVICE = _class.staticFieldId(
    r'PROFILING_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String PROFILING_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get PROFILING_SERVICE =>
      _id_PROFILING_SERVICE.get(_class, const jni$_.JStringNullableType());

  /// from: `static public final int RECEIVER_EXPORTED`
  static const RECEIVER_EXPORTED = 2;

  /// from: `static public final int RECEIVER_NOT_EXPORTED`
  static const RECEIVER_NOT_EXPORTED = 4;

  /// from: `static public final int RECEIVER_VISIBLE_TO_INSTANT_APPS`
  static const RECEIVER_VISIBLE_TO_INSTANT_APPS = 1;
  static final _id_RESTRICTIONS_SERVICE = _class.staticFieldId(
    r'RESTRICTIONS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RESTRICTIONS_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get RESTRICTIONS_SERVICE =>
      _id_RESTRICTIONS_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_ROLE_SERVICE = _class.staticFieldId(
    r'ROLE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ROLE_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ROLE_SERVICE =>
      _id_ROLE_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_SATELLITE_SERVICE = _class.staticFieldId(
    r'SATELLITE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SATELLITE_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SATELLITE_SERVICE =>
      _id_SATELLITE_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_SEARCH_SERVICE = _class.staticFieldId(
    r'SEARCH_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SEARCH_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SEARCH_SERVICE =>
      _id_SEARCH_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_SECURITY_STATE_SERVICE = _class.staticFieldId(
    r'SECURITY_STATE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SECURITY_STATE_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SECURITY_STATE_SERVICE =>
      _id_SECURITY_STATE_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_SENSOR_SERVICE = _class.staticFieldId(
    r'SENSOR_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SENSOR_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SENSOR_SERVICE =>
      _id_SENSOR_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_SHORTCUT_SERVICE = _class.staticFieldId(
    r'SHORTCUT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SHORTCUT_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SHORTCUT_SERVICE =>
      _id_SHORTCUT_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_STATUS_BAR_SERVICE = _class.staticFieldId(
    r'STATUS_BAR_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String STATUS_BAR_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get STATUS_BAR_SERVICE =>
      _id_STATUS_BAR_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_STORAGE_SERVICE = _class.staticFieldId(
    r'STORAGE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String STORAGE_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get STORAGE_SERVICE =>
      _id_STORAGE_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_STORAGE_STATS_SERVICE = _class.staticFieldId(
    r'STORAGE_STATS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String STORAGE_STATS_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get STORAGE_STATS_SERVICE =>
      _id_STORAGE_STATS_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_SYSTEM_HEALTH_SERVICE = _class.staticFieldId(
    r'SYSTEM_HEALTH_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SYSTEM_HEALTH_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SYSTEM_HEALTH_SERVICE =>
      _id_SYSTEM_HEALTH_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_TELECOM_SERVICE = _class.staticFieldId(
    r'TELECOM_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TELECOM_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TELECOM_SERVICE =>
      _id_TELECOM_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_TELEPHONY_IMS_SERVICE = _class.staticFieldId(
    r'TELEPHONY_IMS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TELEPHONY_IMS_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TELEPHONY_IMS_SERVICE =>
      _id_TELEPHONY_IMS_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_TELEPHONY_SERVICE = _class.staticFieldId(
    r'TELEPHONY_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TELEPHONY_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TELEPHONY_SERVICE =>
      _id_TELEPHONY_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_TELEPHONY_SUBSCRIPTION_SERVICE = _class.staticFieldId(
    r'TELEPHONY_SUBSCRIPTION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TELEPHONY_SUBSCRIPTION_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TELEPHONY_SUBSCRIPTION_SERVICE =>
      _id_TELEPHONY_SUBSCRIPTION_SERVICE.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_TETHERING_SERVICE = _class.staticFieldId(
    r'TETHERING_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TETHERING_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TETHERING_SERVICE =>
      _id_TETHERING_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_TEXT_CLASSIFICATION_SERVICE = _class.staticFieldId(
    r'TEXT_CLASSIFICATION_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_CLASSIFICATION_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_CLASSIFICATION_SERVICE =>
      _id_TEXT_CLASSIFICATION_SERVICE.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_TEXT_SERVICES_MANAGER_SERVICE = _class.staticFieldId(
    r'TEXT_SERVICES_MANAGER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TEXT_SERVICES_MANAGER_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TEXT_SERVICES_MANAGER_SERVICE =>
      _id_TEXT_SERVICES_MANAGER_SERVICE.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_TV_AD_SERVICE = _class.staticFieldId(
    r'TV_AD_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TV_AD_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TV_AD_SERVICE =>
      _id_TV_AD_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_TV_INPUT_SERVICE = _class.staticFieldId(
    r'TV_INPUT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TV_INPUT_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TV_INPUT_SERVICE =>
      _id_TV_INPUT_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_TV_INTERACTIVE_APP_SERVICE = _class.staticFieldId(
    r'TV_INTERACTIVE_APP_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TV_INTERACTIVE_APP_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TV_INTERACTIVE_APP_SERVICE =>
      _id_TV_INTERACTIVE_APP_SERVICE.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_UI_MODE_SERVICE = _class.staticFieldId(
    r'UI_MODE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String UI_MODE_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get UI_MODE_SERVICE =>
      _id_UI_MODE_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_USAGE_STATS_SERVICE = _class.staticFieldId(
    r'USAGE_STATS_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String USAGE_STATS_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get USAGE_STATS_SERVICE =>
      _id_USAGE_STATS_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_USB_SERVICE = _class.staticFieldId(
    r'USB_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String USB_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get USB_SERVICE =>
      _id_USB_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_USER_SERVICE = _class.staticFieldId(
    r'USER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String USER_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get USER_SERVICE =>
      _id_USER_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_VIBRATOR_MANAGER_SERVICE = _class.staticFieldId(
    r'VIBRATOR_MANAGER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String VIBRATOR_MANAGER_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get VIBRATOR_MANAGER_SERVICE =>
      _id_VIBRATOR_MANAGER_SERVICE.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_VIBRATOR_SERVICE = _class.staticFieldId(
    r'VIBRATOR_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String VIBRATOR_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get VIBRATOR_SERVICE =>
      _id_VIBRATOR_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_VIRTUAL_DEVICE_SERVICE = _class.staticFieldId(
    r'VIRTUAL_DEVICE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String VIRTUAL_DEVICE_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get VIRTUAL_DEVICE_SERVICE =>
      _id_VIRTUAL_DEVICE_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_VPN_MANAGEMENT_SERVICE = _class.staticFieldId(
    r'VPN_MANAGEMENT_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String VPN_MANAGEMENT_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get VPN_MANAGEMENT_SERVICE =>
      _id_VPN_MANAGEMENT_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_WALLPAPER_SERVICE = _class.staticFieldId(
    r'WALLPAPER_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String WALLPAPER_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get WALLPAPER_SERVICE =>
      _id_WALLPAPER_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_WIFI_AWARE_SERVICE = _class.staticFieldId(
    r'WIFI_AWARE_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String WIFI_AWARE_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get WIFI_AWARE_SERVICE =>
      _id_WIFI_AWARE_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_WIFI_P2P_SERVICE = _class.staticFieldId(
    r'WIFI_P2P_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String WIFI_P2P_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get WIFI_P2P_SERVICE =>
      _id_WIFI_P2P_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_WIFI_RTT_RANGING_SERVICE = _class.staticFieldId(
    r'WIFI_RTT_RANGING_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String WIFI_RTT_RANGING_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get WIFI_RTT_RANGING_SERVICE =>
      _id_WIFI_RTT_RANGING_SERVICE.get(
        _class,
        const jni$_.JStringNullableType(),
      );

  static final _id_WIFI_SERVICE = _class.staticFieldId(
    r'WIFI_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String WIFI_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get WIFI_SERVICE =>
      _id_WIFI_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_WINDOW_SERVICE = _class.staticFieldId(
    r'WINDOW_SERVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String WINDOW_SERVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get WINDOW_SERVICE =>
      _id_WINDOW_SERVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_bindIsolatedService = _class.instanceMethodId(
    r'bindIsolatedService',
    r'(Landroid/content/Intent;Landroid/content/Context$BindServiceFlags;Ljava/lang/String;Ljava/util/concurrent/Executor;Landroid/content/ServiceConnection;)Z',
  );

  static final _bindIsolatedService =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean bindIsolatedService(android.content.Intent intent, android.content.Context$BindServiceFlags bindServiceFlags, java.lang.String string, java.util.concurrent.Executor executor, android.content.ServiceConnection serviceConnection)`
  bool bindIsolatedService(
    jni$_.JObject? intent,
    Context$BindServiceFlags? bindServiceFlags,
    jni$_.JString? string,
    jni$_.JObject? executor,
    jni$_.JObject? serviceConnection,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$bindServiceFlags =
        bindServiceFlags?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$executor = executor?.reference ?? jni$_.jNullReference;
    final _$serviceConnection =
        serviceConnection?.reference ?? jni$_.jNullReference;
    return _bindIsolatedService(
      reference.pointer,
      _id_bindIsolatedService as jni$_.JMethodIDPtr,
      _$intent.pointer,
      _$bindServiceFlags.pointer,
      _$string.pointer,
      _$executor.pointer,
      _$serviceConnection.pointer,
    ).boolean;
  }

  static final _id_bindIsolatedService$1 = _class.instanceMethodId(
    r'bindIsolatedService',
    r'(Landroid/content/Intent;ILjava/lang/String;Ljava/util/concurrent/Executor;Landroid/content/ServiceConnection;)Z',
  );

  static final _bindIsolatedService$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean bindIsolatedService(android.content.Intent intent, int i, java.lang.String string, java.util.concurrent.Executor executor, android.content.ServiceConnection serviceConnection)`
  bool bindIsolatedService$1(
    jni$_.JObject? intent,
    int i,
    jni$_.JString? string,
    jni$_.JObject? executor,
    jni$_.JObject? serviceConnection,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$executor = executor?.reference ?? jni$_.jNullReference;
    final _$serviceConnection =
        serviceConnection?.reference ?? jni$_.jNullReference;
    return _bindIsolatedService$1(
      reference.pointer,
      _id_bindIsolatedService$1 as jni$_.JMethodIDPtr,
      _$intent.pointer,
      i,
      _$string.pointer,
      _$executor.pointer,
      _$serviceConnection.pointer,
    ).boolean;
  }

  static final _id_bindService = _class.instanceMethodId(
    r'bindService',
    r'(Landroid/content/Intent;Landroid/content/Context$BindServiceFlags;Ljava/util/concurrent/Executor;Landroid/content/ServiceConnection;)Z',
  );

  static final _bindService =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean bindService(android.content.Intent intent, android.content.Context$BindServiceFlags bindServiceFlags, java.util.concurrent.Executor executor, android.content.ServiceConnection serviceConnection)`
  bool bindService(
    jni$_.JObject? intent,
    Context$BindServiceFlags? bindServiceFlags,
    jni$_.JObject? executor,
    jni$_.JObject? serviceConnection,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$bindServiceFlags =
        bindServiceFlags?.reference ?? jni$_.jNullReference;
    final _$executor = executor?.reference ?? jni$_.jNullReference;
    final _$serviceConnection =
        serviceConnection?.reference ?? jni$_.jNullReference;
    return _bindService(
      reference.pointer,
      _id_bindService as jni$_.JMethodIDPtr,
      _$intent.pointer,
      _$bindServiceFlags.pointer,
      _$executor.pointer,
      _$serviceConnection.pointer,
    ).boolean;
  }

  static final _id_bindService$1 = _class.instanceMethodId(
    r'bindService',
    r'(Landroid/content/Intent;Landroid/content/ServiceConnection;Landroid/content/Context$BindServiceFlags;)Z',
  );

  static final _bindService$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean bindService(android.content.Intent intent, android.content.ServiceConnection serviceConnection, android.content.Context$BindServiceFlags bindServiceFlags)`
  bool bindService$1(
    jni$_.JObject? intent,
    jni$_.JObject? serviceConnection,
    Context$BindServiceFlags? bindServiceFlags,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$serviceConnection =
        serviceConnection?.reference ?? jni$_.jNullReference;
    final _$bindServiceFlags =
        bindServiceFlags?.reference ?? jni$_.jNullReference;
    return _bindService$1(
      reference.pointer,
      _id_bindService$1 as jni$_.JMethodIDPtr,
      _$intent.pointer,
      _$serviceConnection.pointer,
      _$bindServiceFlags.pointer,
    ).boolean;
  }

  static final _id_bindService$2 = _class.instanceMethodId(
    r'bindService',
    r'(Landroid/content/Intent;Landroid/content/ServiceConnection;I)Z',
  );

  static final _bindService$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract boolean bindService(android.content.Intent intent, android.content.ServiceConnection serviceConnection, int i)`
  bool bindService$2(
    jni$_.JObject? intent,
    jni$_.JObject? serviceConnection,
    int i,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$serviceConnection =
        serviceConnection?.reference ?? jni$_.jNullReference;
    return _bindService$2(
      reference.pointer,
      _id_bindService$2 as jni$_.JMethodIDPtr,
      _$intent.pointer,
      _$serviceConnection.pointer,
      i,
    ).boolean;
  }

  static final _id_bindService$3 = _class.instanceMethodId(
    r'bindService',
    r'(Landroid/content/Intent;ILjava/util/concurrent/Executor;Landroid/content/ServiceConnection;)Z',
  );

  static final _bindService$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean bindService(android.content.Intent intent, int i, java.util.concurrent.Executor executor, android.content.ServiceConnection serviceConnection)`
  bool bindService$3(
    jni$_.JObject? intent,
    int i,
    jni$_.JObject? executor,
    jni$_.JObject? serviceConnection,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$executor = executor?.reference ?? jni$_.jNullReference;
    final _$serviceConnection =
        serviceConnection?.reference ?? jni$_.jNullReference;
    return _bindService$3(
      reference.pointer,
      _id_bindService$3 as jni$_.JMethodIDPtr,
      _$intent.pointer,
      i,
      _$executor.pointer,
      _$serviceConnection.pointer,
    ).boolean;
  }

  static final _id_bindServiceAsUser = _class.instanceMethodId(
    r'bindServiceAsUser',
    r'(Landroid/content/Intent;Landroid/content/ServiceConnection;Landroid/content/Context$BindServiceFlags;Landroid/os/UserHandle;)Z',
  );

  static final _bindServiceAsUser =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean bindServiceAsUser(android.content.Intent intent, android.content.ServiceConnection serviceConnection, android.content.Context$BindServiceFlags bindServiceFlags, android.os.UserHandle userHandle)`
  bool bindServiceAsUser(
    jni$_.JObject? intent,
    jni$_.JObject? serviceConnection,
    Context$BindServiceFlags? bindServiceFlags,
    jni$_.JObject? userHandle,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$serviceConnection =
        serviceConnection?.reference ?? jni$_.jNullReference;
    final _$bindServiceFlags =
        bindServiceFlags?.reference ?? jni$_.jNullReference;
    final _$userHandle = userHandle?.reference ?? jni$_.jNullReference;
    return _bindServiceAsUser(
      reference.pointer,
      _id_bindServiceAsUser as jni$_.JMethodIDPtr,
      _$intent.pointer,
      _$serviceConnection.pointer,
      _$bindServiceFlags.pointer,
      _$userHandle.pointer,
    ).boolean;
  }

  static final _id_bindServiceAsUser$1 = _class.instanceMethodId(
    r'bindServiceAsUser',
    r'(Landroid/content/Intent;Landroid/content/ServiceConnection;ILandroid/os/UserHandle;)Z',
  );

  static final _bindServiceAsUser$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean bindServiceAsUser(android.content.Intent intent, android.content.ServiceConnection serviceConnection, int i, android.os.UserHandle userHandle)`
  bool bindServiceAsUser$1(
    jni$_.JObject? intent,
    jni$_.JObject? serviceConnection,
    int i,
    jni$_.JObject? userHandle,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$serviceConnection =
        serviceConnection?.reference ?? jni$_.jNullReference;
    final _$userHandle = userHandle?.reference ?? jni$_.jNullReference;
    return _bindServiceAsUser$1(
      reference.pointer,
      _id_bindServiceAsUser$1 as jni$_.JMethodIDPtr,
      _$intent.pointer,
      _$serviceConnection.pointer,
      i,
      _$userHandle.pointer,
    ).boolean;
  }

  static final _id_checkCallingOrSelfPermission = _class.instanceMethodId(
    r'checkCallingOrSelfPermission',
    r'(Ljava/lang/String;)I',
  );

  static final _checkCallingOrSelfPermission =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract int checkCallingOrSelfPermission(java.lang.String string)`
  int checkCallingOrSelfPermission(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _checkCallingOrSelfPermission(
      reference.pointer,
      _id_checkCallingOrSelfPermission as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).integer;
  }

  static final _id_checkCallingOrSelfUriPermission = _class.instanceMethodId(
    r'checkCallingOrSelfUriPermission',
    r'(Landroid/net/Uri;I)I',
  );

  static final _checkCallingOrSelfUriPermission =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract int checkCallingOrSelfUriPermission(android.net.Uri uri, int i)`
  int checkCallingOrSelfUriPermission(jni$_.JObject? uri, int i) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    return _checkCallingOrSelfUriPermission(
      reference.pointer,
      _id_checkCallingOrSelfUriPermission as jni$_.JMethodIDPtr,
      _$uri.pointer,
      i,
    ).integer;
  }

  static final _id_checkCallingOrSelfUriPermissions = _class.instanceMethodId(
    r'checkCallingOrSelfUriPermissions',
    r'(Ljava/util/List;I)[I',
  );

  static final _checkCallingOrSelfUriPermissions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public java.lang.Object[] checkCallingOrSelfUriPermissions(java.util.List list, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? checkCallingOrSelfUriPermissions(
    jni$_.JList<jni$_.JObject?>? list,
    int i,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _checkCallingOrSelfUriPermissions(
      reference.pointer,
      _id_checkCallingOrSelfUriPermissions as jni$_.JMethodIDPtr,
      _$list.pointer,
      i,
    ).object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_checkCallingPermission = _class.instanceMethodId(
    r'checkCallingPermission',
    r'(Ljava/lang/String;)I',
  );

  static final _checkCallingPermission =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract int checkCallingPermission(java.lang.String string)`
  int checkCallingPermission(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _checkCallingPermission(
      reference.pointer,
      _id_checkCallingPermission as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).integer;
  }

  static final _id_checkCallingUriPermission = _class.instanceMethodId(
    r'checkCallingUriPermission',
    r'(Landroid/net/Uri;I)I',
  );

  static final _checkCallingUriPermission =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract int checkCallingUriPermission(android.net.Uri uri, int i)`
  int checkCallingUriPermission(jni$_.JObject? uri, int i) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    return _checkCallingUriPermission(
      reference.pointer,
      _id_checkCallingUriPermission as jni$_.JMethodIDPtr,
      _$uri.pointer,
      i,
    ).integer;
  }

  static final _id_checkCallingUriPermissions = _class.instanceMethodId(
    r'checkCallingUriPermissions',
    r'(Ljava/util/List;I)[I',
  );

  static final _checkCallingUriPermissions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public java.lang.Object[] checkCallingUriPermissions(java.util.List list, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? checkCallingUriPermissions(
    jni$_.JList<jni$_.JObject?>? list,
    int i,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _checkCallingUriPermissions(
      reference.pointer,
      _id_checkCallingUriPermissions as jni$_.JMethodIDPtr,
      _$list.pointer,
      i,
    ).object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_checkContentUriPermissionFull = _class.instanceMethodId(
    r'checkContentUriPermissionFull',
    r'(Landroid/net/Uri;III)I',
  );

  static final _checkContentUriPermissionFull =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
            )
          >();

  /// from: `public int checkContentUriPermissionFull(android.net.Uri uri, int i, int i1, int i2)`
  int checkContentUriPermissionFull(jni$_.JObject? uri, int i, int i1, int i2) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    return _checkContentUriPermissionFull(
      reference.pointer,
      _id_checkContentUriPermissionFull as jni$_.JMethodIDPtr,
      _$uri.pointer,
      i,
      i1,
      i2,
    ).integer;
  }

  static final _id_checkPermission = _class.instanceMethodId(
    r'checkPermission',
    r'(Ljava/lang/String;II)I',
  );

  static final _checkPermission =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public abstract int checkPermission(java.lang.String string, int i, int i1)`
  int checkPermission(jni$_.JString? string, int i, int i1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _checkPermission(
      reference.pointer,
      _id_checkPermission as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_checkSelfPermission = _class.instanceMethodId(
    r'checkSelfPermission',
    r'(Ljava/lang/String;)I',
  );

  static final _checkSelfPermission =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract int checkSelfPermission(java.lang.String string)`
  int checkSelfPermission(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _checkSelfPermission(
      reference.pointer,
      _id_checkSelfPermission as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).integer;
  }

  static final _id_checkUriPermission = _class.instanceMethodId(
    r'checkUriPermission',
    r'(Landroid/net/Uri;III)I',
  );

  static final _checkUriPermission =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
            )
          >();

  /// from: `public abstract int checkUriPermission(android.net.Uri uri, int i, int i1, int i2)`
  int checkUriPermission(jni$_.JObject? uri, int i, int i1, int i2) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    return _checkUriPermission(
      reference.pointer,
      _id_checkUriPermission as jni$_.JMethodIDPtr,
      _$uri.pointer,
      i,
      i1,
      i2,
    ).integer;
  }

  static final _id_checkUriPermission$1 = _class.instanceMethodId(
    r'checkUriPermission',
    r'(Landroid/net/Uri;Ljava/lang/String;Ljava/lang/String;III)I',
  );

  static final _checkUriPermission$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
            )
          >();

  /// from: `public abstract int checkUriPermission(android.net.Uri uri, java.lang.String string, java.lang.String string1, int i, int i1, int i2)`
  int checkUriPermission$1(
    jni$_.JObject? uri,
    jni$_.JString? string,
    jni$_.JString? string1,
    int i,
    int i1,
    int i2,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return _checkUriPermission$1(
      reference.pointer,
      _id_checkUriPermission$1 as jni$_.JMethodIDPtr,
      _$uri.pointer,
      _$string.pointer,
      _$string1.pointer,
      i,
      i1,
      i2,
    ).integer;
  }

  static final _id_checkUriPermissions = _class.instanceMethodId(
    r'checkUriPermissions',
    r'(Ljava/util/List;III)[I',
  );

  static final _checkUriPermissions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
            )
          >();

  /// from: `public java.lang.Object[] checkUriPermissions(java.util.List list, int i, int i1, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? checkUriPermissions(
    jni$_.JList<jni$_.JObject?>? list,
    int i,
    int i1,
    int i2,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _checkUriPermissions(
      reference.pointer,
      _id_checkUriPermissions as jni$_.JMethodIDPtr,
      _$list.pointer,
      i,
      i1,
      i2,
    ).object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_clearWallpaper = _class.instanceMethodId(
    r'clearWallpaper',
    r'()V',
  );

  static final _clearWallpaper =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void clearWallpaper()`
  void clearWallpaper() {
    _clearWallpaper(
      reference.pointer,
      _id_clearWallpaper as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_createAttributionContext = _class.instanceMethodId(
    r'createAttributionContext',
    r'(Ljava/lang/String;)Landroid/content/Context;',
  );

  static final _createAttributionContext =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public android.content.Context createAttributionContext(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  Context? createAttributionContext(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _createAttributionContext(
      reference.pointer,
      _id_createAttributionContext as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<Context?>(const $Context$NullableType());
  }

  static final _id_createConfigurationContext = _class.instanceMethodId(
    r'createConfigurationContext',
    r'(Landroid/content/res/Configuration;)Landroid/content/Context;',
  );

  static final _createConfigurationContext =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract android.content.Context createConfigurationContext(android.content.res.Configuration configuration)`
  /// The returned object must be released after use, by calling the [release] method.
  Context? createConfigurationContext(jni$_.JObject? configuration) {
    final _$configuration = configuration?.reference ?? jni$_.jNullReference;
    return _createConfigurationContext(
      reference.pointer,
      _id_createConfigurationContext as jni$_.JMethodIDPtr,
      _$configuration.pointer,
    ).object<Context?>(const $Context$NullableType());
  }

  static final _id_createContext = _class.instanceMethodId(
    r'createContext',
    r'(Landroid/content/ContextParams;)Landroid/content/Context;',
  );

  static final _createContext =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public android.content.Context createContext(android.content.ContextParams contextParams)`
  /// The returned object must be released after use, by calling the [release] method.
  Context? createContext(jni$_.JObject? contextParams) {
    final _$contextParams = contextParams?.reference ?? jni$_.jNullReference;
    return _createContext(
      reference.pointer,
      _id_createContext as jni$_.JMethodIDPtr,
      _$contextParams.pointer,
    ).object<Context?>(const $Context$NullableType());
  }

  static final _id_createContextForSplit = _class.instanceMethodId(
    r'createContextForSplit',
    r'(Ljava/lang/String;)Landroid/content/Context;',
  );

  static final _createContextForSplit =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract android.content.Context createContextForSplit(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  Context? createContextForSplit(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _createContextForSplit(
      reference.pointer,
      _id_createContextForSplit as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<Context?>(const $Context$NullableType());
  }

  static final _id_createDeviceContext = _class.instanceMethodId(
    r'createDeviceContext',
    r'(I)Landroid/content/Context;',
  );

  static final _createDeviceContext =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public android.content.Context createDeviceContext(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  Context? createDeviceContext(int i) {
    return _createDeviceContext(
      reference.pointer,
      _id_createDeviceContext as jni$_.JMethodIDPtr,
      i,
    ).object<Context?>(const $Context$NullableType());
  }

  static final _id_createDeviceProtectedStorageContext = _class
      .instanceMethodId(
        r'createDeviceProtectedStorageContext',
        r'()Landroid/content/Context;',
      );

  static final _createDeviceProtectedStorageContext =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract android.content.Context createDeviceProtectedStorageContext()`
  /// The returned object must be released after use, by calling the [release] method.
  Context? createDeviceProtectedStorageContext() {
    return _createDeviceProtectedStorageContext(
      reference.pointer,
      _id_createDeviceProtectedStorageContext as jni$_.JMethodIDPtr,
    ).object<Context?>(const $Context$NullableType());
  }

  static final _id_createDisplayContext = _class.instanceMethodId(
    r'createDisplayContext',
    r'(Landroid/view/Display;)Landroid/content/Context;',
  );

  static final _createDisplayContext =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract android.content.Context createDisplayContext(android.view.Display display)`
  /// The returned object must be released after use, by calling the [release] method.
  Context? createDisplayContext(jni$_.JObject? display) {
    final _$display = display?.reference ?? jni$_.jNullReference;
    return _createDisplayContext(
      reference.pointer,
      _id_createDisplayContext as jni$_.JMethodIDPtr,
      _$display.pointer,
    ).object<Context?>(const $Context$NullableType());
  }

  static final _id_createPackageContext = _class.instanceMethodId(
    r'createPackageContext',
    r'(Ljava/lang/String;I)Landroid/content/Context;',
  );

  static final _createPackageContext =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract android.content.Context createPackageContext(java.lang.String string, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  Context? createPackageContext(jni$_.JString? string, int i) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _createPackageContext(
      reference.pointer,
      _id_createPackageContext as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
    ).object<Context?>(const $Context$NullableType());
  }

  static final _id_createWindowContext = _class.instanceMethodId(
    r'createWindowContext',
    r'(Landroid/view/Display;ILandroid/os/Bundle;)Landroid/content/Context;',
  );

  static final _createWindowContext =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public android.content.Context createWindowContext(android.view.Display display, int i, android.os.Bundle bundle)`
  /// The returned object must be released after use, by calling the [release] method.
  Context? createWindowContext(
    jni$_.JObject? display,
    int i,
    jni$_.JObject? bundle,
  ) {
    final _$display = display?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    return _createWindowContext(
      reference.pointer,
      _id_createWindowContext as jni$_.JMethodIDPtr,
      _$display.pointer,
      i,
      _$bundle.pointer,
    ).object<Context?>(const $Context$NullableType());
  }

  static final _id_createWindowContext$1 = _class.instanceMethodId(
    r'createWindowContext',
    r'(ILandroid/os/Bundle;)Landroid/content/Context;',
  );

  static final _createWindowContext$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public android.content.Context createWindowContext(int i, android.os.Bundle bundle)`
  /// The returned object must be released after use, by calling the [release] method.
  Context? createWindowContext$1(int i, jni$_.JObject? bundle) {
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    return _createWindowContext$1(
      reference.pointer,
      _id_createWindowContext$1 as jni$_.JMethodIDPtr,
      i,
      _$bundle.pointer,
    ).object<Context?>(const $Context$NullableType());
  }

  static final _id_databaseList = _class.instanceMethodId(
    r'databaseList',
    r'()[Ljava/lang/String;',
  );

  static final _databaseList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.String[] databaseList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?>? databaseList() {
    return _databaseList(
      reference.pointer,
      _id_databaseList as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<jni$_.JString?>?>(
      const jni$_.JArrayNullableType<jni$_.JString?>(
        jni$_.JStringNullableType(),
      ),
    );
  }

  static final _id_deleteDatabase = _class.instanceMethodId(
    r'deleteDatabase',
    r'(Ljava/lang/String;)Z',
  );

  static final _deleteDatabase =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean deleteDatabase(java.lang.String string)`
  bool deleteDatabase(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _deleteDatabase(
      reference.pointer,
      _id_deleteDatabase as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).boolean;
  }

  static final _id_deleteFile = _class.instanceMethodId(
    r'deleteFile',
    r'(Ljava/lang/String;)Z',
  );

  static final _deleteFile =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean deleteFile(java.lang.String string)`
  bool deleteFile(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _deleteFile(
      reference.pointer,
      _id_deleteFile as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).boolean;
  }

  static final _id_deleteSharedPreferences = _class.instanceMethodId(
    r'deleteSharedPreferences',
    r'(Ljava/lang/String;)Z',
  );

  static final _deleteSharedPreferences =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean deleteSharedPreferences(java.lang.String string)`
  bool deleteSharedPreferences(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _deleteSharedPreferences(
      reference.pointer,
      _id_deleteSharedPreferences as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).boolean;
  }

  static final _id_enforceCallingOrSelfPermission = _class.instanceMethodId(
    r'enforceCallingOrSelfPermission',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _enforceCallingOrSelfPermission =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void enforceCallingOrSelfPermission(java.lang.String string, java.lang.String string1)`
  void enforceCallingOrSelfPermission(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _enforceCallingOrSelfPermission(
      reference.pointer,
      _id_enforceCallingOrSelfPermission as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$string1.pointer,
    ).check();
  }

  static final _id_enforceCallingOrSelfUriPermission = _class.instanceMethodId(
    r'enforceCallingOrSelfUriPermission',
    r'(Landroid/net/Uri;ILjava/lang/String;)V',
  );

  static final _enforceCallingOrSelfUriPermission =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void enforceCallingOrSelfUriPermission(android.net.Uri uri, int i, java.lang.String string)`
  void enforceCallingOrSelfUriPermission(
    jni$_.JObject? uri,
    int i,
    jni$_.JString? string,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    _enforceCallingOrSelfUriPermission(
      reference.pointer,
      _id_enforceCallingOrSelfUriPermission as jni$_.JMethodIDPtr,
      _$uri.pointer,
      i,
      _$string.pointer,
    ).check();
  }

  static final _id_enforceCallingPermission = _class.instanceMethodId(
    r'enforceCallingPermission',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _enforceCallingPermission =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void enforceCallingPermission(java.lang.String string, java.lang.String string1)`
  void enforceCallingPermission(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _enforceCallingPermission(
      reference.pointer,
      _id_enforceCallingPermission as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$string1.pointer,
    ).check();
  }

  static final _id_enforceCallingUriPermission = _class.instanceMethodId(
    r'enforceCallingUriPermission',
    r'(Landroid/net/Uri;ILjava/lang/String;)V',
  );

  static final _enforceCallingUriPermission =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void enforceCallingUriPermission(android.net.Uri uri, int i, java.lang.String string)`
  void enforceCallingUriPermission(
    jni$_.JObject? uri,
    int i,
    jni$_.JString? string,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    _enforceCallingUriPermission(
      reference.pointer,
      _id_enforceCallingUriPermission as jni$_.JMethodIDPtr,
      _$uri.pointer,
      i,
      _$string.pointer,
    ).check();
  }

  static final _id_enforcePermission = _class.instanceMethodId(
    r'enforcePermission',
    r'(Ljava/lang/String;IILjava/lang/String;)V',
  );

  static final _enforcePermission =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void enforcePermission(java.lang.String string, int i, int i1, java.lang.String string1)`
  void enforcePermission(
    jni$_.JString? string,
    int i,
    int i1,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _enforcePermission(
      reference.pointer,
      _id_enforcePermission as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
      i1,
      _$string1.pointer,
    ).check();
  }

  static final _id_enforceUriPermission = _class.instanceMethodId(
    r'enforceUriPermission',
    r'(Landroid/net/Uri;IIILjava/lang/String;)V',
  );

  static final _enforceUriPermission =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void enforceUriPermission(android.net.Uri uri, int i, int i1, int i2, java.lang.String string)`
  void enforceUriPermission(
    jni$_.JObject? uri,
    int i,
    int i1,
    int i2,
    jni$_.JString? string,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    _enforceUriPermission(
      reference.pointer,
      _id_enforceUriPermission as jni$_.JMethodIDPtr,
      _$uri.pointer,
      i,
      i1,
      i2,
      _$string.pointer,
    ).check();
  }

  static final _id_enforceUriPermission$1 = _class.instanceMethodId(
    r'enforceUriPermission',
    r'(Landroid/net/Uri;Ljava/lang/String;Ljava/lang/String;IIILjava/lang/String;)V',
  );

  static final _enforceUriPermission$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void enforceUriPermission(android.net.Uri uri, java.lang.String string, java.lang.String string1, int i, int i1, int i2, java.lang.String string2)`
  void enforceUriPermission$1(
    jni$_.JObject? uri,
    jni$_.JString? string,
    jni$_.JString? string1,
    int i,
    int i1,
    int i2,
    jni$_.JString? string2,
  ) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    _enforceUriPermission$1(
      reference.pointer,
      _id_enforceUriPermission$1 as jni$_.JMethodIDPtr,
      _$uri.pointer,
      _$string.pointer,
      _$string1.pointer,
      i,
      i1,
      i2,
      _$string2.pointer,
    ).check();
  }

  static final _id_fileList = _class.instanceMethodId(
    r'fileList',
    r'()[Ljava/lang/String;',
  );

  static final _fileList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.String[] fileList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?>? fileList() {
    return _fileList(
      reference.pointer,
      _id_fileList as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<jni$_.JString?>?>(
      const jni$_.JArrayNullableType<jni$_.JString?>(
        jni$_.JStringNullableType(),
      ),
    );
  }

  static final _id_getApplicationContext = _class.instanceMethodId(
    r'getApplicationContext',
    r'()Landroid/content/Context;',
  );

  static final _getApplicationContext =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract android.content.Context getApplicationContext()`
  /// The returned object must be released after use, by calling the [release] method.
  Context? getApplicationContext() {
    return _getApplicationContext(
      reference.pointer,
      _id_getApplicationContext as jni$_.JMethodIDPtr,
    ).object<Context?>(const $Context$NullableType());
  }

  static final _id_getApplicationInfo = _class.instanceMethodId(
    r'getApplicationInfo',
    r'()Landroid/content/pm/ApplicationInfo;',
  );

  static final _getApplicationInfo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract android.content.pm.ApplicationInfo getApplicationInfo()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getApplicationInfo() {
    return _getApplicationInfo(
      reference.pointer,
      _id_getApplicationInfo as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getAssets = _class.instanceMethodId(
    r'getAssets',
    r'()Landroid/content/res/AssetManager;',
  );

  static final _getAssets =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract android.content.res.AssetManager getAssets()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getAssets() {
    return _getAssets(
      reference.pointer,
      _id_getAssets as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getAttributionSource = _class.instanceMethodId(
    r'getAttributionSource',
    r'()Landroid/content/AttributionSource;',
  );

  static final _getAttributionSource =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.content.AttributionSource getAttributionSource()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getAttributionSource() {
    return _getAttributionSource(
      reference.pointer,
      _id_getAttributionSource as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getAttributionTag = _class.instanceMethodId(
    r'getAttributionTag',
    r'()Ljava/lang/String;',
  );

  static final _getAttributionTag =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getAttributionTag()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getAttributionTag() {
    return _getAttributionTag(
      reference.pointer,
      _id_getAttributionTag as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getCacheDir = _class.instanceMethodId(
    r'getCacheDir',
    r'()Ljava/io/File;',
  );

  static final _getCacheDir =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.io.File getCacheDir()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getCacheDir() {
    return _getCacheDir(
      reference.pointer,
      _id_getCacheDir as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getClassLoader = _class.instanceMethodId(
    r'getClassLoader',
    r'()Ljava/lang/ClassLoader;',
  );

  static final _getClassLoader =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.ClassLoader getClassLoader()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getClassLoader() {
    return _getClassLoader(
      reference.pointer,
      _id_getClassLoader as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getCodeCacheDir = _class.instanceMethodId(
    r'getCodeCacheDir',
    r'()Ljava/io/File;',
  );

  static final _getCodeCacheDir =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.io.File getCodeCacheDir()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getCodeCacheDir() {
    return _getCodeCacheDir(
      reference.pointer,
      _id_getCodeCacheDir as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getColor = _class.instanceMethodId(r'getColor', r'(I)I');

  static final _getColor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final int getColor(int i)`
  int getColor(int i) {
    return _getColor(
      reference.pointer,
      _id_getColor as jni$_.JMethodIDPtr,
      i,
    ).integer;
  }

  static final _id_getColorStateList = _class.instanceMethodId(
    r'getColorStateList',
    r'(I)Landroid/content/res/ColorStateList;',
  );

  static final _getColorStateList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final android.content.res.ColorStateList getColorStateList(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getColorStateList(int i) {
    return _getColorStateList(
      reference.pointer,
      _id_getColorStateList as jni$_.JMethodIDPtr,
      i,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getContentResolver = _class.instanceMethodId(
    r'getContentResolver',
    r'()Landroid/content/ContentResolver;',
  );

  static final _getContentResolver =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract android.content.ContentResolver getContentResolver()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getContentResolver() {
    return _getContentResolver(
      reference.pointer,
      _id_getContentResolver as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getDataDir = _class.instanceMethodId(
    r'getDataDir',
    r'()Ljava/io/File;',
  );

  static final _getDataDir =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.io.File getDataDir()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getDataDir() {
    return _getDataDir(
      reference.pointer,
      _id_getDataDir as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getDatabasePath = _class.instanceMethodId(
    r'getDatabasePath',
    r'(Ljava/lang/String;)Ljava/io/File;',
  );

  static final _getDatabasePath =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.io.File getDatabasePath(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getDatabasePath(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getDatabasePath(
      reference.pointer,
      _id_getDatabasePath as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getDeviceId = _class.instanceMethodId(
    r'getDeviceId',
    r'()I',
  );

  static final _getDeviceId =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getDeviceId()`
  int getDeviceId() {
    return _getDeviceId(
      reference.pointer,
      _id_getDeviceId as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getDir = _class.instanceMethodId(
    r'getDir',
    r'(Ljava/lang/String;I)Ljava/io/File;',
  );

  static final _getDir =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract java.io.File getDir(java.lang.String string, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getDir(jni$_.JString? string, int i) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getDir(
      reference.pointer,
      _id_getDir as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getDisplay = _class.instanceMethodId(
    r'getDisplay',
    r'()Landroid/view/Display;',
  );

  static final _getDisplay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.view.Display getDisplay()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getDisplay() {
    return _getDisplay(
      reference.pointer,
      _id_getDisplay as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getDrawable = _class.instanceMethodId(
    r'getDrawable',
    r'(I)Landroid/graphics/drawable/Drawable;',
  );

  static final _getDrawable =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final android.graphics.drawable.Drawable getDrawable(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getDrawable(int i) {
    return _getDrawable(
      reference.pointer,
      _id_getDrawable as jni$_.JMethodIDPtr,
      i,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getExternalCacheDir = _class.instanceMethodId(
    r'getExternalCacheDir',
    r'()Ljava/io/File;',
  );

  static final _getExternalCacheDir =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.io.File getExternalCacheDir()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getExternalCacheDir() {
    return _getExternalCacheDir(
      reference.pointer,
      _id_getExternalCacheDir as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getExternalCacheDirs = _class.instanceMethodId(
    r'getExternalCacheDirs',
    r'()[Ljava/io/File;',
  );

  static final _getExternalCacheDirs =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.io.File[] getExternalCacheDirs()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JObject?>? getExternalCacheDirs() {
    return _getExternalCacheDirs(
      reference.pointer,
      _id_getExternalCacheDirs as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<jni$_.JObject?>?>(
      const jni$_.JArrayNullableType<jni$_.JObject?>(
        jni$_.JObjectNullableType(),
      ),
    );
  }

  static final _id_getExternalFilesDir = _class.instanceMethodId(
    r'getExternalFilesDir',
    r'(Ljava/lang/String;)Ljava/io/File;',
  );

  static final _getExternalFilesDir =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.io.File getExternalFilesDir(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getExternalFilesDir(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getExternalFilesDir(
      reference.pointer,
      _id_getExternalFilesDir as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getExternalFilesDirs = _class.instanceMethodId(
    r'getExternalFilesDirs',
    r'(Ljava/lang/String;)[Ljava/io/File;',
  );

  static final _getExternalFilesDirs =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.io.File[] getExternalFilesDirs(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JObject?>? getExternalFilesDirs(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getExternalFilesDirs(
      reference.pointer,
      _id_getExternalFilesDirs as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JArray<jni$_.JObject?>?>(
      const jni$_.JArrayNullableType<jni$_.JObject?>(
        jni$_.JObjectNullableType(),
      ),
    );
  }

  static final _id_getExternalMediaDirs = _class.instanceMethodId(
    r'getExternalMediaDirs',
    r'()[Ljava/io/File;',
  );

  static final _getExternalMediaDirs =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.io.File[] getExternalMediaDirs()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JObject?>? getExternalMediaDirs() {
    return _getExternalMediaDirs(
      reference.pointer,
      _id_getExternalMediaDirs as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<jni$_.JObject?>?>(
      const jni$_.JArrayNullableType<jni$_.JObject?>(
        jni$_.JObjectNullableType(),
      ),
    );
  }

  static final _id_getFileStreamPath = _class.instanceMethodId(
    r'getFileStreamPath',
    r'(Ljava/lang/String;)Ljava/io/File;',
  );

  static final _getFileStreamPath =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.io.File getFileStreamPath(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getFileStreamPath(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getFileStreamPath(
      reference.pointer,
      _id_getFileStreamPath as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getFilesDir = _class.instanceMethodId(
    r'getFilesDir',
    r'()Ljava/io/File;',
  );

  static final _getFilesDir =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.io.File getFilesDir()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getFilesDir() {
    return _getFilesDir(
      reference.pointer,
      _id_getFilesDir as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getMainExecutor = _class.instanceMethodId(
    r'getMainExecutor',
    r'()Ljava/util/concurrent/Executor;',
  );

  static final _getMainExecutor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.concurrent.Executor getMainExecutor()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getMainExecutor() {
    return _getMainExecutor(
      reference.pointer,
      _id_getMainExecutor as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getMainLooper = _class.instanceMethodId(
    r'getMainLooper',
    r'()Landroid/os/Looper;',
  );

  static final _getMainLooper =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract android.os.Looper getMainLooper()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getMainLooper() {
    return _getMainLooper(
      reference.pointer,
      _id_getMainLooper as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getNoBackupFilesDir = _class.instanceMethodId(
    r'getNoBackupFilesDir',
    r'()Ljava/io/File;',
  );

  static final _getNoBackupFilesDir =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.io.File getNoBackupFilesDir()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getNoBackupFilesDir() {
    return _getNoBackupFilesDir(
      reference.pointer,
      _id_getNoBackupFilesDir as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getObbDir = _class.instanceMethodId(
    r'getObbDir',
    r'()Ljava/io/File;',
  );

  static final _getObbDir =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.io.File getObbDir()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getObbDir() {
    return _getObbDir(
      reference.pointer,
      _id_getObbDir as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getObbDirs = _class.instanceMethodId(
    r'getObbDirs',
    r'()[Ljava/io/File;',
  );

  static final _getObbDirs =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.io.File[] getObbDirs()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JObject?>? getObbDirs() {
    return _getObbDirs(
      reference.pointer,
      _id_getObbDirs as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<jni$_.JObject?>?>(
      const jni$_.JArrayNullableType<jni$_.JObject?>(
        jni$_.JObjectNullableType(),
      ),
    );
  }

  static final _id_getOpPackageName = _class.instanceMethodId(
    r'getOpPackageName',
    r'()Ljava/lang/String;',
  );

  static final _getOpPackageName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getOpPackageName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getOpPackageName() {
    return _getOpPackageName(
      reference.pointer,
      _id_getOpPackageName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getPackageCodePath = _class.instanceMethodId(
    r'getPackageCodePath',
    r'()Ljava/lang/String;',
  );

  static final _getPackageCodePath =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.String getPackageCodePath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getPackageCodePath() {
    return _getPackageCodePath(
      reference.pointer,
      _id_getPackageCodePath as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getPackageManager = _class.instanceMethodId(
    r'getPackageManager',
    r'()Landroid/content/pm/PackageManager;',
  );

  static final _getPackageManager =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract android.content.pm.PackageManager getPackageManager()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getPackageManager() {
    return _getPackageManager(
      reference.pointer,
      _id_getPackageManager as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getPackageName = _class.instanceMethodId(
    r'getPackageName',
    r'()Ljava/lang/String;',
  );

  static final _getPackageName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.String getPackageName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getPackageName() {
    return _getPackageName(
      reference.pointer,
      _id_getPackageName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getPackageResourcePath = _class.instanceMethodId(
    r'getPackageResourcePath',
    r'()Ljava/lang/String;',
  );

  static final _getPackageResourcePath =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.String getPackageResourcePath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getPackageResourcePath() {
    return _getPackageResourcePath(
      reference.pointer,
      _id_getPackageResourcePath as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getParams = _class.instanceMethodId(
    r'getParams',
    r'()Landroid/content/ContextParams;',
  );

  static final _getParams =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.content.ContextParams getParams()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getParams() {
    return _getParams(
      reference.pointer,
      _id_getParams as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getResources = _class.instanceMethodId(
    r'getResources',
    r'()Landroid/content/res/Resources;',
  );

  static final _getResources =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract android.content.res.Resources getResources()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getResources() {
    return _getResources(
      reference.pointer,
      _id_getResources as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getSharedPreferences = _class.instanceMethodId(
    r'getSharedPreferences',
    r'(Ljava/lang/String;I)Landroid/content/SharedPreferences;',
  );

  static final _getSharedPreferences =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract android.content.SharedPreferences getSharedPreferences(java.lang.String string, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getSharedPreferences(jni$_.JString? string, int i) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getSharedPreferences(
      reference.pointer,
      _id_getSharedPreferences as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getString = _class.instanceMethodId(
    r'getString',
    r'(I)Ljava/lang/String;',
  );

  static final _getString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final java.lang.String getString(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getString(int i) {
    return _getString(
      reference.pointer,
      _id_getString as jni$_.JMethodIDPtr,
      i,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getString$1 = _class.instanceMethodId(
    r'getString',
    r'(I[Ljava/lang/Object;)Ljava/lang/String;',
  );

  static final _getString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final java.lang.String getString(int i, java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getString$1(int i, jni$_.JArray<jni$_.JObject?>? objects) {
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _getString$1(
      reference.pointer,
      _id_getString$1 as jni$_.JMethodIDPtr,
      i,
      _$objects.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getSystemService = _class.instanceMethodId(
    r'getSystemService',
    r'(Ljava/lang/Class;)Ljava/lang/Object;',
  );

  static final _getSystemService =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final T getSystemService(java.lang.Class class)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? getSystemService<$T extends jni$_.JObject?>(
    jni$_.JObject? class$, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$class$ = class$?.reference ?? jni$_.jNullReference;
    return _getSystemService(
      reference.pointer,
      _id_getSystemService as jni$_.JMethodIDPtr,
      _$class$.pointer,
    ).object<$T?>(T.nullableType);
  }

  static final _id_getSystemService$1 = _class.instanceMethodId(
    r'getSystemService',
    r'(Ljava/lang/String;)Ljava/lang/Object;',
  );

  static final _getSystemService$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.lang.Object getSystemService(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getSystemService$1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getSystemService$1(
      reference.pointer,
      _id_getSystemService$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getSystemServiceName = _class.instanceMethodId(
    r'getSystemServiceName',
    r'(Ljava/lang/Class;)Ljava/lang/String;',
  );

  static final _getSystemServiceName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.lang.String getSystemServiceName(java.lang.Class class)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getSystemServiceName(jni$_.JObject? class$) {
    final _$class$ = class$?.reference ?? jni$_.jNullReference;
    return _getSystemServiceName(
      reference.pointer,
      _id_getSystemServiceName as jni$_.JMethodIDPtr,
      _$class$.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getText = _class.instanceMethodId(
    r'getText',
    r'(I)Ljava/lang/CharSequence;',
  );

  static final _getText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final java.lang.CharSequence getText(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getText(int i) {
    return _getText(
      reference.pointer,
      _id_getText as jni$_.JMethodIDPtr,
      i,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getTheme = _class.instanceMethodId(
    r'getTheme',
    r'()Landroid/content/res/Resources$Theme;',
  );

  static final _getTheme =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract android.content.res.Resources$Theme getTheme()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getTheme() {
    return _getTheme(
      reference.pointer,
      _id_getTheme as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getWallpaper = _class.instanceMethodId(
    r'getWallpaper',
    r'()Landroid/graphics/drawable/Drawable;',
  );

  static final _getWallpaper =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract android.graphics.drawable.Drawable getWallpaper()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getWallpaper() {
    return _getWallpaper(
      reference.pointer,
      _id_getWallpaper as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getWallpaperDesiredMinimumHeight = _class.instanceMethodId(
    r'getWallpaperDesiredMinimumHeight',
    r'()I',
  );

  static final _getWallpaperDesiredMinimumHeight =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int getWallpaperDesiredMinimumHeight()`
  int getWallpaperDesiredMinimumHeight() {
    return _getWallpaperDesiredMinimumHeight(
      reference.pointer,
      _id_getWallpaperDesiredMinimumHeight as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getWallpaperDesiredMinimumWidth = _class.instanceMethodId(
    r'getWallpaperDesiredMinimumWidth',
    r'()I',
  );

  static final _getWallpaperDesiredMinimumWidth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int getWallpaperDesiredMinimumWidth()`
  int getWallpaperDesiredMinimumWidth() {
    return _getWallpaperDesiredMinimumWidth(
      reference.pointer,
      _id_getWallpaperDesiredMinimumWidth as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_grantUriPermission = _class.instanceMethodId(
    r'grantUriPermission',
    r'(Ljava/lang/String;Landroid/net/Uri;I)V',
  );

  static final _grantUriPermission =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract void grantUriPermission(java.lang.String string, android.net.Uri uri, int i)`
  void grantUriPermission(jni$_.JString? string, jni$_.JObject? uri, int i) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    _grantUriPermission(
      reference.pointer,
      _id_grantUriPermission as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$uri.pointer,
      i,
    ).check();
  }

  static final _id_isDeviceProtectedStorage = _class.instanceMethodId(
    r'isDeviceProtectedStorage',
    r'()Z',
  );

  static final _isDeviceProtectedStorage =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract boolean isDeviceProtectedStorage()`
  bool isDeviceProtectedStorage() {
    return _isDeviceProtectedStorage(
      reference.pointer,
      _id_isDeviceProtectedStorage as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isRestricted = _class.instanceMethodId(
    r'isRestricted',
    r'()Z',
  );

  static final _isRestricted =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isRestricted()`
  bool isRestricted() {
    return _isRestricted(
      reference.pointer,
      _id_isRestricted as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isUiContext = _class.instanceMethodId(
    r'isUiContext',
    r'()Z',
  );

  static final _isUiContext =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isUiContext()`
  bool isUiContext() {
    return _isUiContext(
      reference.pointer,
      _id_isUiContext as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_moveDatabaseFrom = _class.instanceMethodId(
    r'moveDatabaseFrom',
    r'(Landroid/content/Context;Ljava/lang/String;)Z',
  );

  static final _moveDatabaseFrom =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean moveDatabaseFrom(android.content.Context context, java.lang.String string)`
  bool moveDatabaseFrom(Context? context, jni$_.JString? string) {
    final _$context = context?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _moveDatabaseFrom(
      reference.pointer,
      _id_moveDatabaseFrom as jni$_.JMethodIDPtr,
      _$context.pointer,
      _$string.pointer,
    ).boolean;
  }

  static final _id_moveSharedPreferencesFrom = _class.instanceMethodId(
    r'moveSharedPreferencesFrom',
    r'(Landroid/content/Context;Ljava/lang/String;)Z',
  );

  static final _moveSharedPreferencesFrom =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean moveSharedPreferencesFrom(android.content.Context context, java.lang.String string)`
  bool moveSharedPreferencesFrom(Context? context, jni$_.JString? string) {
    final _$context = context?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _moveSharedPreferencesFrom(
      reference.pointer,
      _id_moveSharedPreferencesFrom as jni$_.JMethodIDPtr,
      _$context.pointer,
      _$string.pointer,
    ).boolean;
  }

  static final _id_obtainStyledAttributes = _class.instanceMethodId(
    r'obtainStyledAttributes',
    r'(Landroid/util/AttributeSet;[I)Landroid/content/res/TypedArray;',
  );

  static final _obtainStyledAttributes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final android.content.res.TypedArray obtainStyledAttributes(android.util.AttributeSet attributeSet, int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? obtainStyledAttributes(
    jni$_.JObject? attributeSet,
    jni$_.JIntArray? is$,
  ) {
    final _$attributeSet = attributeSet?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _obtainStyledAttributes(
      reference.pointer,
      _id_obtainStyledAttributes as jni$_.JMethodIDPtr,
      _$attributeSet.pointer,
      _$is$.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_obtainStyledAttributes$1 = _class.instanceMethodId(
    r'obtainStyledAttributes',
    r'(Landroid/util/AttributeSet;[III)Landroid/content/res/TypedArray;',
  );

  static final _obtainStyledAttributes$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public final android.content.res.TypedArray obtainStyledAttributes(android.util.AttributeSet attributeSet, int[] is, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? obtainStyledAttributes$1(
    jni$_.JObject? attributeSet,
    jni$_.JIntArray? is$,
    int i,
    int i1,
  ) {
    final _$attributeSet = attributeSet?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _obtainStyledAttributes$1(
      reference.pointer,
      _id_obtainStyledAttributes$1 as jni$_.JMethodIDPtr,
      _$attributeSet.pointer,
      _$is$.pointer,
      i,
      i1,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_obtainStyledAttributes$2 = _class.instanceMethodId(
    r'obtainStyledAttributes',
    r'(I[I)Landroid/content/res/TypedArray;',
  );

  static final _obtainStyledAttributes$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final android.content.res.TypedArray obtainStyledAttributes(int i, int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? obtainStyledAttributes$2(int i, jni$_.JIntArray? is$) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _obtainStyledAttributes$2(
      reference.pointer,
      _id_obtainStyledAttributes$2 as jni$_.JMethodIDPtr,
      i,
      _$is$.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_obtainStyledAttributes$3 = _class.instanceMethodId(
    r'obtainStyledAttributes',
    r'([I)Landroid/content/res/TypedArray;',
  );

  static final _obtainStyledAttributes$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final android.content.res.TypedArray obtainStyledAttributes(int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? obtainStyledAttributes$3(jni$_.JIntArray? is$) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _obtainStyledAttributes$3(
      reference.pointer,
      _id_obtainStyledAttributes$3 as jni$_.JMethodIDPtr,
      _$is$.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_openFileInput = _class.instanceMethodId(
    r'openFileInput',
    r'(Ljava/lang/String;)Ljava/io/FileInputStream;',
  );

  static final _openFileInput =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.io.FileInputStream openFileInput(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? openFileInput(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _openFileInput(
      reference.pointer,
      _id_openFileInput as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_openFileOutput = _class.instanceMethodId(
    r'openFileOutput',
    r'(Ljava/lang/String;I)Ljava/io/FileOutputStream;',
  );

  static final _openFileOutput =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract java.io.FileOutputStream openFileOutput(java.lang.String string, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? openFileOutput(jni$_.JString? string, int i) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _openFileOutput(
      reference.pointer,
      _id_openFileOutput as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_openOrCreateDatabase = _class.instanceMethodId(
    r'openOrCreateDatabase',
    r'(Ljava/lang/String;ILandroid/database/sqlite/SQLiteDatabase$CursorFactory;)Landroid/database/sqlite/SQLiteDatabase;',
  );

  static final _openOrCreateDatabase =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract android.database.sqlite.SQLiteDatabase openOrCreateDatabase(java.lang.String string, int i, android.database.sqlite.SQLiteDatabase$CursorFactory cursorFactory)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? openOrCreateDatabase(
    jni$_.JString? string,
    int i,
    jni$_.JObject? cursorFactory,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$cursorFactory = cursorFactory?.reference ?? jni$_.jNullReference;
    return _openOrCreateDatabase(
      reference.pointer,
      _id_openOrCreateDatabase as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
      _$cursorFactory.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_openOrCreateDatabase$1 = _class.instanceMethodId(
    r'openOrCreateDatabase',
    r'(Ljava/lang/String;ILandroid/database/sqlite/SQLiteDatabase$CursorFactory;Landroid/database/DatabaseErrorHandler;)Landroid/database/sqlite/SQLiteDatabase;',
  );

  static final _openOrCreateDatabase$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract android.database.sqlite.SQLiteDatabase openOrCreateDatabase(java.lang.String string, int i, android.database.sqlite.SQLiteDatabase$CursorFactory cursorFactory, android.database.DatabaseErrorHandler databaseErrorHandler)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? openOrCreateDatabase$1(
    jni$_.JString? string,
    int i,
    jni$_.JObject? cursorFactory,
    jni$_.JObject? databaseErrorHandler,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$cursorFactory = cursorFactory?.reference ?? jni$_.jNullReference;
    final _$databaseErrorHandler =
        databaseErrorHandler?.reference ?? jni$_.jNullReference;
    return _openOrCreateDatabase$1(
      reference.pointer,
      _id_openOrCreateDatabase$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
      _$cursorFactory.pointer,
      _$databaseErrorHandler.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_peekWallpaper = _class.instanceMethodId(
    r'peekWallpaper',
    r'()Landroid/graphics/drawable/Drawable;',
  );

  static final _peekWallpaper =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract android.graphics.drawable.Drawable peekWallpaper()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? peekWallpaper() {
    return _peekWallpaper(
      reference.pointer,
      _id_peekWallpaper as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_registerComponentCallbacks = _class.instanceMethodId(
    r'registerComponentCallbacks',
    r'(Landroid/content/ComponentCallbacks;)V',
  );

  static final _registerComponentCallbacks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void registerComponentCallbacks(android.content.ComponentCallbacks componentCallbacks)`
  void registerComponentCallbacks(jni$_.JObject? componentCallbacks) {
    final _$componentCallbacks =
        componentCallbacks?.reference ?? jni$_.jNullReference;
    _registerComponentCallbacks(
      reference.pointer,
      _id_registerComponentCallbacks as jni$_.JMethodIDPtr,
      _$componentCallbacks.pointer,
    ).check();
  }

  static final _id_registerDeviceIdChangeListener = _class.instanceMethodId(
    r'registerDeviceIdChangeListener',
    r'(Ljava/util/concurrent/Executor;Ljava/util/function/IntConsumer;)V',
  );

  static final _registerDeviceIdChangeListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void registerDeviceIdChangeListener(java.util.concurrent.Executor executor, java.util.function.IntConsumer intConsumer)`
  void registerDeviceIdChangeListener(
    jni$_.JObject? executor,
    jni$_.JObject? intConsumer,
  ) {
    final _$executor = executor?.reference ?? jni$_.jNullReference;
    final _$intConsumer = intConsumer?.reference ?? jni$_.jNullReference;
    _registerDeviceIdChangeListener(
      reference.pointer,
      _id_registerDeviceIdChangeListener as jni$_.JMethodIDPtr,
      _$executor.pointer,
      _$intConsumer.pointer,
    ).check();
  }

  static final _id_registerReceiver = _class.instanceMethodId(
    r'registerReceiver',
    r'(Landroid/content/BroadcastReceiver;Landroid/content/IntentFilter;)Landroid/content/Intent;',
  );

  static final _registerReceiver =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract android.content.Intent registerReceiver(android.content.BroadcastReceiver broadcastReceiver, android.content.IntentFilter intentFilter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? registerReceiver(
    jni$_.JObject? broadcastReceiver,
    jni$_.JObject? intentFilter,
  ) {
    final _$broadcastReceiver =
        broadcastReceiver?.reference ?? jni$_.jNullReference;
    final _$intentFilter = intentFilter?.reference ?? jni$_.jNullReference;
    return _registerReceiver(
      reference.pointer,
      _id_registerReceiver as jni$_.JMethodIDPtr,
      _$broadcastReceiver.pointer,
      _$intentFilter.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_registerReceiver$1 = _class.instanceMethodId(
    r'registerReceiver',
    r'(Landroid/content/BroadcastReceiver;Landroid/content/IntentFilter;I)Landroid/content/Intent;',
  );

  static final _registerReceiver$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract android.content.Intent registerReceiver(android.content.BroadcastReceiver broadcastReceiver, android.content.IntentFilter intentFilter, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? registerReceiver$1(
    jni$_.JObject? broadcastReceiver,
    jni$_.JObject? intentFilter,
    int i,
  ) {
    final _$broadcastReceiver =
        broadcastReceiver?.reference ?? jni$_.jNullReference;
    final _$intentFilter = intentFilter?.reference ?? jni$_.jNullReference;
    return _registerReceiver$1(
      reference.pointer,
      _id_registerReceiver$1 as jni$_.JMethodIDPtr,
      _$broadcastReceiver.pointer,
      _$intentFilter.pointer,
      i,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_registerReceiver$2 = _class.instanceMethodId(
    r'registerReceiver',
    r'(Landroid/content/BroadcastReceiver;Landroid/content/IntentFilter;Ljava/lang/String;Landroid/os/Handler;)Landroid/content/Intent;',
  );

  static final _registerReceiver$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract android.content.Intent registerReceiver(android.content.BroadcastReceiver broadcastReceiver, android.content.IntentFilter intentFilter, java.lang.String string, android.os.Handler handler)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? registerReceiver$2(
    jni$_.JObject? broadcastReceiver,
    jni$_.JObject? intentFilter,
    jni$_.JString? string,
    jni$_.JObject? handler,
  ) {
    final _$broadcastReceiver =
        broadcastReceiver?.reference ?? jni$_.jNullReference;
    final _$intentFilter = intentFilter?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$handler = handler?.reference ?? jni$_.jNullReference;
    return _registerReceiver$2(
      reference.pointer,
      _id_registerReceiver$2 as jni$_.JMethodIDPtr,
      _$broadcastReceiver.pointer,
      _$intentFilter.pointer,
      _$string.pointer,
      _$handler.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_registerReceiver$3 = _class.instanceMethodId(
    r'registerReceiver',
    r'(Landroid/content/BroadcastReceiver;Landroid/content/IntentFilter;Ljava/lang/String;Landroid/os/Handler;I)Landroid/content/Intent;',
  );

  static final _registerReceiver$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract android.content.Intent registerReceiver(android.content.BroadcastReceiver broadcastReceiver, android.content.IntentFilter intentFilter, java.lang.String string, android.os.Handler handler, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? registerReceiver$3(
    jni$_.JObject? broadcastReceiver,
    jni$_.JObject? intentFilter,
    jni$_.JString? string,
    jni$_.JObject? handler,
    int i,
  ) {
    final _$broadcastReceiver =
        broadcastReceiver?.reference ?? jni$_.jNullReference;
    final _$intentFilter = intentFilter?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$handler = handler?.reference ?? jni$_.jNullReference;
    return _registerReceiver$3(
      reference.pointer,
      _id_registerReceiver$3 as jni$_.JMethodIDPtr,
      _$broadcastReceiver.pointer,
      _$intentFilter.pointer,
      _$string.pointer,
      _$handler.pointer,
      i,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_removeStickyBroadcast = _class.instanceMethodId(
    r'removeStickyBroadcast',
    r'(Landroid/content/Intent;)V',
  );

  static final _removeStickyBroadcast =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void removeStickyBroadcast(android.content.Intent intent)`
  void removeStickyBroadcast(jni$_.JObject? intent) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    _removeStickyBroadcast(
      reference.pointer,
      _id_removeStickyBroadcast as jni$_.JMethodIDPtr,
      _$intent.pointer,
    ).check();
  }

  static final _id_removeStickyBroadcastAsUser = _class.instanceMethodId(
    r'removeStickyBroadcastAsUser',
    r'(Landroid/content/Intent;Landroid/os/UserHandle;)V',
  );

  static final _removeStickyBroadcastAsUser =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void removeStickyBroadcastAsUser(android.content.Intent intent, android.os.UserHandle userHandle)`
  void removeStickyBroadcastAsUser(
    jni$_.JObject? intent,
    jni$_.JObject? userHandle,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$userHandle = userHandle?.reference ?? jni$_.jNullReference;
    _removeStickyBroadcastAsUser(
      reference.pointer,
      _id_removeStickyBroadcastAsUser as jni$_.JMethodIDPtr,
      _$intent.pointer,
      _$userHandle.pointer,
    ).check();
  }

  static final _id_revokeSelfPermissionOnKill = _class.instanceMethodId(
    r'revokeSelfPermissionOnKill',
    r'(Ljava/lang/String;)V',
  );

  static final _revokeSelfPermissionOnKill =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void revokeSelfPermissionOnKill(java.lang.String string)`
  void revokeSelfPermissionOnKill(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _revokeSelfPermissionOnKill(
      reference.pointer,
      _id_revokeSelfPermissionOnKill as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_revokeSelfPermissionsOnKill = _class.instanceMethodId(
    r'revokeSelfPermissionsOnKill',
    r'(Ljava/util/Collection;)V',
  );

  static final _revokeSelfPermissionsOnKill =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void revokeSelfPermissionsOnKill(java.util.Collection collection)`
  void revokeSelfPermissionsOnKill(jni$_.JObject? collection) {
    final _$collection = collection?.reference ?? jni$_.jNullReference;
    _revokeSelfPermissionsOnKill(
      reference.pointer,
      _id_revokeSelfPermissionsOnKill as jni$_.JMethodIDPtr,
      _$collection.pointer,
    ).check();
  }

  static final _id_revokeUriPermission = _class.instanceMethodId(
    r'revokeUriPermission',
    r'(Landroid/net/Uri;I)V',
  );

  static final _revokeUriPermission =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract void revokeUriPermission(android.net.Uri uri, int i)`
  void revokeUriPermission(jni$_.JObject? uri, int i) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    _revokeUriPermission(
      reference.pointer,
      _id_revokeUriPermission as jni$_.JMethodIDPtr,
      _$uri.pointer,
      i,
    ).check();
  }

  static final _id_revokeUriPermission$1 = _class.instanceMethodId(
    r'revokeUriPermission',
    r'(Ljava/lang/String;Landroid/net/Uri;I)V',
  );

  static final _revokeUriPermission$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract void revokeUriPermission(java.lang.String string, android.net.Uri uri, int i)`
  void revokeUriPermission$1(jni$_.JString? string, jni$_.JObject? uri, int i) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    _revokeUriPermission$1(
      reference.pointer,
      _id_revokeUriPermission$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$uri.pointer,
      i,
    ).check();
  }

  static final _id_sendBroadcast = _class.instanceMethodId(
    r'sendBroadcast',
    r'(Landroid/content/Intent;)V',
  );

  static final _sendBroadcast =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void sendBroadcast(android.content.Intent intent)`
  void sendBroadcast(jni$_.JObject? intent) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    _sendBroadcast(
      reference.pointer,
      _id_sendBroadcast as jni$_.JMethodIDPtr,
      _$intent.pointer,
    ).check();
  }

  static final _id_sendBroadcast$1 = _class.instanceMethodId(
    r'sendBroadcast',
    r'(Landroid/content/Intent;Ljava/lang/String;)V',
  );

  static final _sendBroadcast$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void sendBroadcast(android.content.Intent intent, java.lang.String string)`
  void sendBroadcast$1(jni$_.JObject? intent, jni$_.JString? string) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    _sendBroadcast$1(
      reference.pointer,
      _id_sendBroadcast$1 as jni$_.JMethodIDPtr,
      _$intent.pointer,
      _$string.pointer,
    ).check();
  }

  static final _id_sendBroadcast$2 = _class.instanceMethodId(
    r'sendBroadcast',
    r'(Landroid/content/Intent;Ljava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _sendBroadcast$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void sendBroadcast(android.content.Intent intent, java.lang.String string, android.os.Bundle bundle)`
  void sendBroadcast$2(
    jni$_.JObject? intent,
    jni$_.JString? string,
    jni$_.JObject? bundle,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _sendBroadcast$2(
      reference.pointer,
      _id_sendBroadcast$2 as jni$_.JMethodIDPtr,
      _$intent.pointer,
      _$string.pointer,
      _$bundle.pointer,
    ).check();
  }

  static final _id_sendBroadcastAsUser = _class.instanceMethodId(
    r'sendBroadcastAsUser',
    r'(Landroid/content/Intent;Landroid/os/UserHandle;)V',
  );

  static final _sendBroadcastAsUser =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void sendBroadcastAsUser(android.content.Intent intent, android.os.UserHandle userHandle)`
  void sendBroadcastAsUser(jni$_.JObject? intent, jni$_.JObject? userHandle) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$userHandle = userHandle?.reference ?? jni$_.jNullReference;
    _sendBroadcastAsUser(
      reference.pointer,
      _id_sendBroadcastAsUser as jni$_.JMethodIDPtr,
      _$intent.pointer,
      _$userHandle.pointer,
    ).check();
  }

  static final _id_sendBroadcastAsUser$1 = _class.instanceMethodId(
    r'sendBroadcastAsUser',
    r'(Landroid/content/Intent;Landroid/os/UserHandle;Ljava/lang/String;)V',
  );

  static final _sendBroadcastAsUser$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void sendBroadcastAsUser(android.content.Intent intent, android.os.UserHandle userHandle, java.lang.String string)`
  void sendBroadcastAsUser$1(
    jni$_.JObject? intent,
    jni$_.JObject? userHandle,
    jni$_.JString? string,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$userHandle = userHandle?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    _sendBroadcastAsUser$1(
      reference.pointer,
      _id_sendBroadcastAsUser$1 as jni$_.JMethodIDPtr,
      _$intent.pointer,
      _$userHandle.pointer,
      _$string.pointer,
    ).check();
  }

  static final _id_sendBroadcastWithMultiplePermissions = _class
      .instanceMethodId(
        r'sendBroadcastWithMultiplePermissions',
        r'(Landroid/content/Intent;[Ljava/lang/String;)V',
      );

  static final _sendBroadcastWithMultiplePermissions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void sendBroadcastWithMultiplePermissions(android.content.Intent intent, java.lang.String[] strings)`
  void sendBroadcastWithMultiplePermissions(
    jni$_.JObject? intent,
    jni$_.JArray<jni$_.JString?>? strings,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$strings = strings?.reference ?? jni$_.jNullReference;
    _sendBroadcastWithMultiplePermissions(
      reference.pointer,
      _id_sendBroadcastWithMultiplePermissions as jni$_.JMethodIDPtr,
      _$intent.pointer,
      _$strings.pointer,
    ).check();
  }

  static final _id_sendOrderedBroadcast = _class.instanceMethodId(
    r'sendOrderedBroadcast',
    r'(Landroid/content/Intent;Ljava/lang/String;)V',
  );

  static final _sendOrderedBroadcast =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void sendOrderedBroadcast(android.content.Intent intent, java.lang.String string)`
  void sendOrderedBroadcast(jni$_.JObject? intent, jni$_.JString? string) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    _sendOrderedBroadcast(
      reference.pointer,
      _id_sendOrderedBroadcast as jni$_.JMethodIDPtr,
      _$intent.pointer,
      _$string.pointer,
    ).check();
  }

  static final _id_sendOrderedBroadcast$1 = _class.instanceMethodId(
    r'sendOrderedBroadcast',
    r'(Landroid/content/Intent;Ljava/lang/String;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _sendOrderedBroadcast$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void sendOrderedBroadcast(android.content.Intent intent, java.lang.String string, android.content.BroadcastReceiver broadcastReceiver, android.os.Handler handler, int i, java.lang.String string1, android.os.Bundle bundle)`
  void sendOrderedBroadcast$1(
    jni$_.JObject? intent,
    jni$_.JString? string,
    jni$_.JObject? broadcastReceiver,
    jni$_.JObject? handler,
    int i,
    jni$_.JString? string1,
    jni$_.JObject? bundle,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$broadcastReceiver =
        broadcastReceiver?.reference ?? jni$_.jNullReference;
    final _$handler = handler?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _sendOrderedBroadcast$1(
      reference.pointer,
      _id_sendOrderedBroadcast$1 as jni$_.JMethodIDPtr,
      _$intent.pointer,
      _$string.pointer,
      _$broadcastReceiver.pointer,
      _$handler.pointer,
      i,
      _$string1.pointer,
      _$bundle.pointer,
    ).check();
  }

  static final _id_sendOrderedBroadcast$2 = _class.instanceMethodId(
    r'sendOrderedBroadcast',
    r'(Landroid/content/Intent;Ljava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _sendOrderedBroadcast$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void sendOrderedBroadcast(android.content.Intent intent, java.lang.String string, android.os.Bundle bundle)`
  void sendOrderedBroadcast$2(
    jni$_.JObject? intent,
    jni$_.JString? string,
    jni$_.JObject? bundle,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _sendOrderedBroadcast$2(
      reference.pointer,
      _id_sendOrderedBroadcast$2 as jni$_.JMethodIDPtr,
      _$intent.pointer,
      _$string.pointer,
      _$bundle.pointer,
    ).check();
  }

  static final _id_sendOrderedBroadcast$3 = _class.instanceMethodId(
    r'sendOrderedBroadcast',
    r'(Landroid/content/Intent;Ljava/lang/String;Landroid/os/Bundle;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _sendOrderedBroadcast$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void sendOrderedBroadcast(android.content.Intent intent, java.lang.String string, android.os.Bundle bundle, android.content.BroadcastReceiver broadcastReceiver, android.os.Handler handler, int i, java.lang.String string1, android.os.Bundle bundle1)`
  void sendOrderedBroadcast$3(
    jni$_.JObject? intent,
    jni$_.JString? string,
    jni$_.JObject? bundle,
    jni$_.JObject? broadcastReceiver,
    jni$_.JObject? handler,
    int i,
    jni$_.JString? string1,
    jni$_.JObject? bundle1,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    final _$broadcastReceiver =
        broadcastReceiver?.reference ?? jni$_.jNullReference;
    final _$handler = handler?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$bundle1 = bundle1?.reference ?? jni$_.jNullReference;
    _sendOrderedBroadcast$3(
      reference.pointer,
      _id_sendOrderedBroadcast$3 as jni$_.JMethodIDPtr,
      _$intent.pointer,
      _$string.pointer,
      _$bundle.pointer,
      _$broadcastReceiver.pointer,
      _$handler.pointer,
      i,
      _$string1.pointer,
      _$bundle1.pointer,
    ).check();
  }

  static final _id_sendOrderedBroadcast$4 = _class.instanceMethodId(
    r'sendOrderedBroadcast',
    r'(Landroid/content/Intent;Ljava/lang/String;Ljava/lang/String;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _sendOrderedBroadcast$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void sendOrderedBroadcast(android.content.Intent intent, java.lang.String string, java.lang.String string1, android.content.BroadcastReceiver broadcastReceiver, android.os.Handler handler, int i, java.lang.String string2, android.os.Bundle bundle)`
  void sendOrderedBroadcast$4(
    jni$_.JObject? intent,
    jni$_.JString? string,
    jni$_.JString? string1,
    jni$_.JObject? broadcastReceiver,
    jni$_.JObject? handler,
    int i,
    jni$_.JString? string2,
    jni$_.JObject? bundle,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$broadcastReceiver =
        broadcastReceiver?.reference ?? jni$_.jNullReference;
    final _$handler = handler?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _sendOrderedBroadcast$4(
      reference.pointer,
      _id_sendOrderedBroadcast$4 as jni$_.JMethodIDPtr,
      _$intent.pointer,
      _$string.pointer,
      _$string1.pointer,
      _$broadcastReceiver.pointer,
      _$handler.pointer,
      i,
      _$string2.pointer,
      _$bundle.pointer,
    ).check();
  }

  static final _id_sendOrderedBroadcastAsUser = _class.instanceMethodId(
    r'sendOrderedBroadcastAsUser',
    r'(Landroid/content/Intent;Landroid/os/UserHandle;Ljava/lang/String;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _sendOrderedBroadcastAsUser =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void sendOrderedBroadcastAsUser(android.content.Intent intent, android.os.UserHandle userHandle, java.lang.String string, android.content.BroadcastReceiver broadcastReceiver, android.os.Handler handler, int i, java.lang.String string1, android.os.Bundle bundle)`
  void sendOrderedBroadcastAsUser(
    jni$_.JObject? intent,
    jni$_.JObject? userHandle,
    jni$_.JString? string,
    jni$_.JObject? broadcastReceiver,
    jni$_.JObject? handler,
    int i,
    jni$_.JString? string1,
    jni$_.JObject? bundle,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$userHandle = userHandle?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$broadcastReceiver =
        broadcastReceiver?.reference ?? jni$_.jNullReference;
    final _$handler = handler?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _sendOrderedBroadcastAsUser(
      reference.pointer,
      _id_sendOrderedBroadcastAsUser as jni$_.JMethodIDPtr,
      _$intent.pointer,
      _$userHandle.pointer,
      _$string.pointer,
      _$broadcastReceiver.pointer,
      _$handler.pointer,
      i,
      _$string1.pointer,
      _$bundle.pointer,
    ).check();
  }

  static final _id_sendStickyBroadcast = _class.instanceMethodId(
    r'sendStickyBroadcast',
    r'(Landroid/content/Intent;)V',
  );

  static final _sendStickyBroadcast =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void sendStickyBroadcast(android.content.Intent intent)`
  void sendStickyBroadcast(jni$_.JObject? intent) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    _sendStickyBroadcast(
      reference.pointer,
      _id_sendStickyBroadcast as jni$_.JMethodIDPtr,
      _$intent.pointer,
    ).check();
  }

  static final _id_sendStickyBroadcast$1 = _class.instanceMethodId(
    r'sendStickyBroadcast',
    r'(Landroid/content/Intent;Landroid/os/Bundle;)V',
  );

  static final _sendStickyBroadcast$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void sendStickyBroadcast(android.content.Intent intent, android.os.Bundle bundle)`
  void sendStickyBroadcast$1(jni$_.JObject? intent, jni$_.JObject? bundle) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _sendStickyBroadcast$1(
      reference.pointer,
      _id_sendStickyBroadcast$1 as jni$_.JMethodIDPtr,
      _$intent.pointer,
      _$bundle.pointer,
    ).check();
  }

  static final _id_sendStickyBroadcastAsUser = _class.instanceMethodId(
    r'sendStickyBroadcastAsUser',
    r'(Landroid/content/Intent;Landroid/os/UserHandle;)V',
  );

  static final _sendStickyBroadcastAsUser =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void sendStickyBroadcastAsUser(android.content.Intent intent, android.os.UserHandle userHandle)`
  void sendStickyBroadcastAsUser(
    jni$_.JObject? intent,
    jni$_.JObject? userHandle,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$userHandle = userHandle?.reference ?? jni$_.jNullReference;
    _sendStickyBroadcastAsUser(
      reference.pointer,
      _id_sendStickyBroadcastAsUser as jni$_.JMethodIDPtr,
      _$intent.pointer,
      _$userHandle.pointer,
    ).check();
  }

  static final _id_sendStickyOrderedBroadcast = _class.instanceMethodId(
    r'sendStickyOrderedBroadcast',
    r'(Landroid/content/Intent;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _sendStickyOrderedBroadcast =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void sendStickyOrderedBroadcast(android.content.Intent intent, android.content.BroadcastReceiver broadcastReceiver, android.os.Handler handler, int i, java.lang.String string, android.os.Bundle bundle)`
  void sendStickyOrderedBroadcast(
    jni$_.JObject? intent,
    jni$_.JObject? broadcastReceiver,
    jni$_.JObject? handler,
    int i,
    jni$_.JString? string,
    jni$_.JObject? bundle,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$broadcastReceiver =
        broadcastReceiver?.reference ?? jni$_.jNullReference;
    final _$handler = handler?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _sendStickyOrderedBroadcast(
      reference.pointer,
      _id_sendStickyOrderedBroadcast as jni$_.JMethodIDPtr,
      _$intent.pointer,
      _$broadcastReceiver.pointer,
      _$handler.pointer,
      i,
      _$string.pointer,
      _$bundle.pointer,
    ).check();
  }

  static final _id_sendStickyOrderedBroadcastAsUser = _class.instanceMethodId(
    r'sendStickyOrderedBroadcastAsUser',
    r'(Landroid/content/Intent;Landroid/os/UserHandle;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V',
  );

  static final _sendStickyOrderedBroadcastAsUser =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void sendStickyOrderedBroadcastAsUser(android.content.Intent intent, android.os.UserHandle userHandle, android.content.BroadcastReceiver broadcastReceiver, android.os.Handler handler, int i, java.lang.String string, android.os.Bundle bundle)`
  void sendStickyOrderedBroadcastAsUser(
    jni$_.JObject? intent,
    jni$_.JObject? userHandle,
    jni$_.JObject? broadcastReceiver,
    jni$_.JObject? handler,
    int i,
    jni$_.JString? string,
    jni$_.JObject? bundle,
  ) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$userHandle = userHandle?.reference ?? jni$_.jNullReference;
    final _$broadcastReceiver =
        broadcastReceiver?.reference ?? jni$_.jNullReference;
    final _$handler = handler?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _sendStickyOrderedBroadcastAsUser(
      reference.pointer,
      _id_sendStickyOrderedBroadcastAsUser as jni$_.JMethodIDPtr,
      _$intent.pointer,
      _$userHandle.pointer,
      _$broadcastReceiver.pointer,
      _$handler.pointer,
      i,
      _$string.pointer,
      _$bundle.pointer,
    ).check();
  }

  static final _id_setTheme = _class.instanceMethodId(r'setTheme', r'(I)V');

  static final _setTheme =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void setTheme(int i)`
  void setTheme(int i) {
    _setTheme(reference.pointer, _id_setTheme as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_setWallpaper = _class.instanceMethodId(
    r'setWallpaper',
    r'(Landroid/graphics/Bitmap;)V',
  );

  static final _setWallpaper =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void setWallpaper(android.graphics.Bitmap bitmap)`
  void setWallpaper(jni$_.JObject? bitmap) {
    final _$bitmap = bitmap?.reference ?? jni$_.jNullReference;
    _setWallpaper(
      reference.pointer,
      _id_setWallpaper as jni$_.JMethodIDPtr,
      _$bitmap.pointer,
    ).check();
  }

  static final _id_setWallpaper$1 = _class.instanceMethodId(
    r'setWallpaper',
    r'(Ljava/io/InputStream;)V',
  );

  static final _setWallpaper$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void setWallpaper(java.io.InputStream inputStream)`
  void setWallpaper$1(jni$_.JObject? inputStream) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    _setWallpaper$1(
      reference.pointer,
      _id_setWallpaper$1 as jni$_.JMethodIDPtr,
      _$inputStream.pointer,
    ).check();
  }

  static final _id_startActivities = _class.instanceMethodId(
    r'startActivities',
    r'([Landroid/content/Intent;)V',
  );

  static final _startActivities =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void startActivities(android.content.Intent[] intents)`
  void startActivities(jni$_.JArray<jni$_.JObject?>? intents) {
    final _$intents = intents?.reference ?? jni$_.jNullReference;
    _startActivities(
      reference.pointer,
      _id_startActivities as jni$_.JMethodIDPtr,
      _$intents.pointer,
    ).check();
  }

  static final _id_startActivities$1 = _class.instanceMethodId(
    r'startActivities',
    r'([Landroid/content/Intent;Landroid/os/Bundle;)V',
  );

  static final _startActivities$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void startActivities(android.content.Intent[] intents, android.os.Bundle bundle)`
  void startActivities$1(
    jni$_.JArray<jni$_.JObject?>? intents,
    jni$_.JObject? bundle,
  ) {
    final _$intents = intents?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _startActivities$1(
      reference.pointer,
      _id_startActivities$1 as jni$_.JMethodIDPtr,
      _$intents.pointer,
      _$bundle.pointer,
    ).check();
  }

  static final _id_startActivity = _class.instanceMethodId(
    r'startActivity',
    r'(Landroid/content/Intent;)V',
  );

  static final _startActivity =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void startActivity(android.content.Intent intent)`
  void startActivity(jni$_.JObject? intent) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    _startActivity(
      reference.pointer,
      _id_startActivity as jni$_.JMethodIDPtr,
      _$intent.pointer,
    ).check();
  }

  static final _id_startActivity$1 = _class.instanceMethodId(
    r'startActivity',
    r'(Landroid/content/Intent;Landroid/os/Bundle;)V',
  );

  static final _startActivity$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void startActivity(android.content.Intent intent, android.os.Bundle bundle)`
  void startActivity$1(jni$_.JObject? intent, jni$_.JObject? bundle) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _startActivity$1(
      reference.pointer,
      _id_startActivity$1 as jni$_.JMethodIDPtr,
      _$intent.pointer,
      _$bundle.pointer,
    ).check();
  }

  static final _id_startForegroundService = _class.instanceMethodId(
    r'startForegroundService',
    r'(Landroid/content/Intent;)Landroid/content/ComponentName;',
  );

  static final _startForegroundService =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract android.content.ComponentName startForegroundService(android.content.Intent intent)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? startForegroundService(jni$_.JObject? intent) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    return _startForegroundService(
      reference.pointer,
      _id_startForegroundService as jni$_.JMethodIDPtr,
      _$intent.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_startInstrumentation = _class.instanceMethodId(
    r'startInstrumentation',
    r'(Landroid/content/ComponentName;Ljava/lang/String;Landroid/os/Bundle;)Z',
  );

  static final _startInstrumentation =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean startInstrumentation(android.content.ComponentName componentName, java.lang.String string, android.os.Bundle bundle)`
  bool startInstrumentation(
    jni$_.JObject? componentName,
    jni$_.JString? string,
    jni$_.JObject? bundle,
  ) {
    final _$componentName = componentName?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    return _startInstrumentation(
      reference.pointer,
      _id_startInstrumentation as jni$_.JMethodIDPtr,
      _$componentName.pointer,
      _$string.pointer,
      _$bundle.pointer,
    ).boolean;
  }

  static final _id_startIntentSender = _class.instanceMethodId(
    r'startIntentSender',
    r'(Landroid/content/IntentSender;Landroid/content/Intent;III)V',
  );

  static final _startIntentSender =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
            )
          >();

  /// from: `public abstract void startIntentSender(android.content.IntentSender intentSender, android.content.Intent intent, int i, int i1, int i2)`
  void startIntentSender(
    jni$_.JObject? intentSender,
    jni$_.JObject? intent,
    int i,
    int i1,
    int i2,
  ) {
    final _$intentSender = intentSender?.reference ?? jni$_.jNullReference;
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    _startIntentSender(
      reference.pointer,
      _id_startIntentSender as jni$_.JMethodIDPtr,
      _$intentSender.pointer,
      _$intent.pointer,
      i,
      i1,
      i2,
    ).check();
  }

  static final _id_startIntentSender$1 = _class.instanceMethodId(
    r'startIntentSender',
    r'(Landroid/content/IntentSender;Landroid/content/Intent;IIILandroid/os/Bundle;)V',
  );

  static final _startIntentSender$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void startIntentSender(android.content.IntentSender intentSender, android.content.Intent intent, int i, int i1, int i2, android.os.Bundle bundle)`
  void startIntentSender$1(
    jni$_.JObject? intentSender,
    jni$_.JObject? intent,
    int i,
    int i1,
    int i2,
    jni$_.JObject? bundle,
  ) {
    final _$intentSender = intentSender?.reference ?? jni$_.jNullReference;
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    final _$bundle = bundle?.reference ?? jni$_.jNullReference;
    _startIntentSender$1(
      reference.pointer,
      _id_startIntentSender$1 as jni$_.JMethodIDPtr,
      _$intentSender.pointer,
      _$intent.pointer,
      i,
      i1,
      i2,
      _$bundle.pointer,
    ).check();
  }

  static final _id_startService = _class.instanceMethodId(
    r'startService',
    r'(Landroid/content/Intent;)Landroid/content/ComponentName;',
  );

  static final _startService =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract android.content.ComponentName startService(android.content.Intent intent)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? startService(jni$_.JObject? intent) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    return _startService(
      reference.pointer,
      _id_startService as jni$_.JMethodIDPtr,
      _$intent.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_stopService = _class.instanceMethodId(
    r'stopService',
    r'(Landroid/content/Intent;)Z',
  );

  static final _stopService =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean stopService(android.content.Intent intent)`
  bool stopService(jni$_.JObject? intent) {
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    return _stopService(
      reference.pointer,
      _id_stopService as jni$_.JMethodIDPtr,
      _$intent.pointer,
    ).boolean;
  }

  static final _id_unbindService = _class.instanceMethodId(
    r'unbindService',
    r'(Landroid/content/ServiceConnection;)V',
  );

  static final _unbindService =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void unbindService(android.content.ServiceConnection serviceConnection)`
  void unbindService(jni$_.JObject? serviceConnection) {
    final _$serviceConnection =
        serviceConnection?.reference ?? jni$_.jNullReference;
    _unbindService(
      reference.pointer,
      _id_unbindService as jni$_.JMethodIDPtr,
      _$serviceConnection.pointer,
    ).check();
  }

  static final _id_unregisterComponentCallbacks = _class.instanceMethodId(
    r'unregisterComponentCallbacks',
    r'(Landroid/content/ComponentCallbacks;)V',
  );

  static final _unregisterComponentCallbacks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void unregisterComponentCallbacks(android.content.ComponentCallbacks componentCallbacks)`
  void unregisterComponentCallbacks(jni$_.JObject? componentCallbacks) {
    final _$componentCallbacks =
        componentCallbacks?.reference ?? jni$_.jNullReference;
    _unregisterComponentCallbacks(
      reference.pointer,
      _id_unregisterComponentCallbacks as jni$_.JMethodIDPtr,
      _$componentCallbacks.pointer,
    ).check();
  }

  static final _id_unregisterDeviceIdChangeListener = _class.instanceMethodId(
    r'unregisterDeviceIdChangeListener',
    r'(Ljava/util/function/IntConsumer;)V',
  );

  static final _unregisterDeviceIdChangeListener =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void unregisterDeviceIdChangeListener(java.util.function.IntConsumer intConsumer)`
  void unregisterDeviceIdChangeListener(jni$_.JObject? intConsumer) {
    final _$intConsumer = intConsumer?.reference ?? jni$_.jNullReference;
    _unregisterDeviceIdChangeListener(
      reference.pointer,
      _id_unregisterDeviceIdChangeListener as jni$_.JMethodIDPtr,
      _$intConsumer.pointer,
    ).check();
  }

  static final _id_unregisterReceiver = _class.instanceMethodId(
    r'unregisterReceiver',
    r'(Landroid/content/BroadcastReceiver;)V',
  );

  static final _unregisterReceiver =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void unregisterReceiver(android.content.BroadcastReceiver broadcastReceiver)`
  void unregisterReceiver(jni$_.JObject? broadcastReceiver) {
    final _$broadcastReceiver =
        broadcastReceiver?.reference ?? jni$_.jNullReference;
    _unregisterReceiver(
      reference.pointer,
      _id_unregisterReceiver as jni$_.JMethodIDPtr,
      _$broadcastReceiver.pointer,
    ).check();
  }

  static final _id_updateServiceGroup = _class.instanceMethodId(
    r'updateServiceGroup',
    r'(Landroid/content/ServiceConnection;II)V',
  );

  static final _updateServiceGroup =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void updateServiceGroup(android.content.ServiceConnection serviceConnection, int i, int i1)`
  void updateServiceGroup(jni$_.JObject? serviceConnection, int i, int i1) {
    final _$serviceConnection =
        serviceConnection?.reference ?? jni$_.jNullReference;
    _updateServiceGroup(
      reference.pointer,
      _id_updateServiceGroup as jni$_.JMethodIDPtr,
      _$serviceConnection.pointer,
      i,
      i1,
    ).check();
  }
}

final class $Context$NullableType extends jni$_.JObjType<Context?> {
  @jni$_.internal
  const $Context$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/content/Context;';

  @jni$_.internal
  @core$_.override
  Context? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Context.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Context?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Context$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Context$NullableType) &&
        other is $Context$NullableType;
  }
}

final class $Context$Type extends jni$_.JObjType<Context> {
  @jni$_.internal
  const $Context$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/content/Context;';

  @jni$_.internal
  @core$_.override
  Context fromReference(jni$_.JReference reference) =>
      Context.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Context?> get nullableType => const $Context$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Context$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Context$Type) && other is $Context$Type;
  }
}

/// from: `androidx.health.connect.client.request.AggregateRequest`
class AggregateRequest extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<AggregateRequest> $type;

  @jni$_.internal
  AggregateRequest.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/health/connect/client/request/AggregateRequest',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $AggregateRequest$NullableType();
  static const type = $AggregateRequest$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/util/Set;Landroidx/health/connect/client/time/TimeRangeFilter;Ljava/util/Set;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.util.Set set, androidx.health.connect.client.time.TimeRangeFilter timeRangeFilter, java.util.Set set1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory AggregateRequest(
    jni$_.JSet<AggregateMetric<jni$_.JObject>> set,
    TimeRangeFilter timeRangeFilter,
    jni$_.JSet<jni$_.JObject> set1,
  ) {
    final _$set = set.reference;
    final _$timeRangeFilter = timeRangeFilter.reference;
    final _$set1 = set1.reference;
    return AggregateRequest.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$set.pointer,
        _$timeRangeFilter.pointer,
        _$set1.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/util/Set;Landroidx/health/connect/client/time/TimeRangeFilter;Ljava/util/Set;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(java.util.Set set, androidx.health.connect.client.time.TimeRangeFilter timeRangeFilter, java.util.Set set1, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory AggregateRequest.new$1(
    jni$_.JSet<jni$_.JObject?>? set,
    TimeRangeFilter? timeRangeFilter,
    jni$_.JSet<jni$_.JObject?>? set1,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$set = set?.reference ?? jni$_.jNullReference;
    final _$timeRangeFilter =
        timeRangeFilter?.reference ?? jni$_.jNullReference;
    final _$set1 = set1?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return AggregateRequest.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$set.pointer,
        _$timeRangeFilter.pointer,
        _$set1.pointer,
        i,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }
}

final class $AggregateRequest$NullableType
    extends jni$_.JObjType<AggregateRequest?> {
  @jni$_.internal
  const $AggregateRequest$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/request/AggregateRequest;';

  @jni$_.internal
  @core$_.override
  AggregateRequest? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : AggregateRequest.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AggregateRequest?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AggregateRequest$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AggregateRequest$NullableType) &&
        other is $AggregateRequest$NullableType;
  }
}

final class $AggregateRequest$Type extends jni$_.JObjType<AggregateRequest> {
  @jni$_.internal
  const $AggregateRequest$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/request/AggregateRequest;';

  @jni$_.internal
  @core$_.override
  AggregateRequest fromReference(jni$_.JReference reference) =>
      AggregateRequest.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AggregateRequest?> get nullableType =>
      const $AggregateRequest$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AggregateRequest$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AggregateRequest$Type) &&
        other is $AggregateRequest$Type;
  }
}

/// from: `androidx.health.connect.client.time.TimeRangeFilter$Companion`
class TimeRangeFilter$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<TimeRangeFilter$Companion> $type;

  @jni$_.internal
  TimeRangeFilter$Companion.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/health/connect/client/time/TimeRangeFilter$Companion',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $TimeRangeFilter$Companion$NullableType();
  static const type = $TimeRangeFilter$Companion$Type();
  static final _id_between = _class.instanceMethodId(
    r'between',
    r'(Ljava/time/Instant;Ljava/time/Instant;)Landroidx/health/connect/client/time/TimeRangeFilter;',
  );

  static final _between =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final androidx.health.connect.client.time.TimeRangeFilter between(java.time.Instant instant, java.time.Instant instant1)`
  /// The returned object must be released after use, by calling the [release] method.
  TimeRangeFilter between(Instant instant, Instant instant1) {
    final _$instant = instant.reference;
    final _$instant1 = instant1.reference;
    return _between(
      reference.pointer,
      _id_between as jni$_.JMethodIDPtr,
      _$instant.pointer,
      _$instant1.pointer,
    ).object<TimeRangeFilter>(const $TimeRangeFilter$Type());
  }

  static final _id_between$1 = _class.instanceMethodId(
    r'between',
    r'(Ljava/time/LocalDateTime;Ljava/time/LocalDateTime;)Landroidx/health/connect/client/time/TimeRangeFilter;',
  );

  static final _between$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final androidx.health.connect.client.time.TimeRangeFilter between(java.time.LocalDateTime localDateTime, java.time.LocalDateTime localDateTime1)`
  /// The returned object must be released after use, by calling the [release] method.
  TimeRangeFilter between$1(
    jni$_.JObject localDateTime,
    jni$_.JObject localDateTime1,
  ) {
    final _$localDateTime = localDateTime.reference;
    final _$localDateTime1 = localDateTime1.reference;
    return _between$1(
      reference.pointer,
      _id_between$1 as jni$_.JMethodIDPtr,
      _$localDateTime.pointer,
      _$localDateTime1.pointer,
    ).object<TimeRangeFilter>(const $TimeRangeFilter$Type());
  }

  static final _id_before = _class.instanceMethodId(
    r'before',
    r'(Ljava/time/Instant;)Landroidx/health/connect/client/time/TimeRangeFilter;',
  );

  static final _before =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final androidx.health.connect.client.time.TimeRangeFilter before(java.time.Instant instant)`
  /// The returned object must be released after use, by calling the [release] method.
  TimeRangeFilter before(Instant instant) {
    final _$instant = instant.reference;
    return _before(
      reference.pointer,
      _id_before as jni$_.JMethodIDPtr,
      _$instant.pointer,
    ).object<TimeRangeFilter>(const $TimeRangeFilter$Type());
  }

  static final _id_before$1 = _class.instanceMethodId(
    r'before',
    r'(Ljava/time/LocalDateTime;)Landroidx/health/connect/client/time/TimeRangeFilter;',
  );

  static final _before$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final androidx.health.connect.client.time.TimeRangeFilter before(java.time.LocalDateTime localDateTime)`
  /// The returned object must be released after use, by calling the [release] method.
  TimeRangeFilter before$1(jni$_.JObject localDateTime) {
    final _$localDateTime = localDateTime.reference;
    return _before$1(
      reference.pointer,
      _id_before$1 as jni$_.JMethodIDPtr,
      _$localDateTime.pointer,
    ).object<TimeRangeFilter>(const $TimeRangeFilter$Type());
  }

  static final _id_after = _class.instanceMethodId(
    r'after',
    r'(Ljava/time/Instant;)Landroidx/health/connect/client/time/TimeRangeFilter;',
  );

  static final _after =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final androidx.health.connect.client.time.TimeRangeFilter after(java.time.Instant instant)`
  /// The returned object must be released after use, by calling the [release] method.
  TimeRangeFilter after(Instant instant) {
    final _$instant = instant.reference;
    return _after(
      reference.pointer,
      _id_after as jni$_.JMethodIDPtr,
      _$instant.pointer,
    ).object<TimeRangeFilter>(const $TimeRangeFilter$Type());
  }

  static final _id_after$1 = _class.instanceMethodId(
    r'after',
    r'(Ljava/time/LocalDateTime;)Landroidx/health/connect/client/time/TimeRangeFilter;',
  );

  static final _after$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final androidx.health.connect.client.time.TimeRangeFilter after(java.time.LocalDateTime localDateTime)`
  /// The returned object must be released after use, by calling the [release] method.
  TimeRangeFilter after$1(jni$_.JObject localDateTime) {
    final _$localDateTime = localDateTime.reference;
    return _after$1(
      reference.pointer,
      _id_after$1 as jni$_.JMethodIDPtr,
      _$localDateTime.pointer,
    ).object<TimeRangeFilter>(const $TimeRangeFilter$Type());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory TimeRangeFilter$Companion(jni$_.JObject? defaultConstructorMarker) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return TimeRangeFilter$Companion.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }
}

final class $TimeRangeFilter$Companion$NullableType
    extends jni$_.JObjType<TimeRangeFilter$Companion?> {
  @jni$_.internal
  const $TimeRangeFilter$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/time/TimeRangeFilter$Companion;';

  @jni$_.internal
  @core$_.override
  TimeRangeFilter$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : TimeRangeFilter$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<TimeRangeFilter$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($TimeRangeFilter$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($TimeRangeFilter$Companion$NullableType) &&
        other is $TimeRangeFilter$Companion$NullableType;
  }
}

final class $TimeRangeFilter$Companion$Type
    extends jni$_.JObjType<TimeRangeFilter$Companion> {
  @jni$_.internal
  const $TimeRangeFilter$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/time/TimeRangeFilter$Companion;';

  @jni$_.internal
  @core$_.override
  TimeRangeFilter$Companion fromReference(jni$_.JReference reference) =>
      TimeRangeFilter$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<TimeRangeFilter$Companion?> get nullableType =>
      const $TimeRangeFilter$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($TimeRangeFilter$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($TimeRangeFilter$Companion$Type) &&
        other is $TimeRangeFilter$Companion$Type;
  }
}

/// from: `androidx.health.connect.client.time.TimeRangeFilter`
class TimeRangeFilter extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<TimeRangeFilter> $type;

  @jni$_.internal
  TimeRangeFilter.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/health/connect/client/time/TimeRangeFilter',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $TimeRangeFilter$NullableType();
  static const type = $TimeRangeFilter$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Landroidx/health/connect/client/time/TimeRangeFilter$Companion;',
  );

  /// from: `static public final androidx.health.connect.client.time.TimeRangeFilter$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static TimeRangeFilter$Companion get Companion =>
      _id_Companion.get(_class, const $TimeRangeFilter$Companion$Type());

  static final _id_new$ = _class.constructorId(
    r'(Ljava/time/Instant;Ljava/time/Instant;Ljava/time/LocalDateTime;Ljava/time/LocalDateTime;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.time.Instant instant, java.time.Instant instant1, java.time.LocalDateTime localDateTime, java.time.LocalDateTime localDateTime1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory TimeRangeFilter(
    Instant? instant,
    Instant? instant1,
    jni$_.JObject? localDateTime,
    jni$_.JObject? localDateTime1,
  ) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    final _$instant1 = instant1?.reference ?? jni$_.jNullReference;
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    final _$localDateTime1 = localDateTime1?.reference ?? jni$_.jNullReference;
    return TimeRangeFilter.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$instant.pointer,
        _$instant1.pointer,
        _$localDateTime.pointer,
        _$localDateTime1.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/time/Instant;Ljava/time/Instant;Ljava/time/LocalDateTime;Ljava/time/LocalDateTime;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(java.time.Instant instant, java.time.Instant instant1, java.time.LocalDateTime localDateTime, java.time.LocalDateTime localDateTime1, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory TimeRangeFilter.new$1(
    Instant? instant,
    Instant? instant1,
    jni$_.JObject? localDateTime,
    jni$_.JObject? localDateTime1,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    final _$instant1 = instant1?.reference ?? jni$_.jNullReference;
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    final _$localDateTime1 = localDateTime1?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return TimeRangeFilter.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$instant.pointer,
        _$instant1.pointer,
        _$localDateTime.pointer,
        _$localDateTime1.pointer,
        i,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }

  static final _id_getStartTime = _class.instanceMethodId(
    r'getStartTime',
    r'()Ljava/time/Instant;',
  );

  static final _getStartTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.time.Instant getStartTime()`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? getStartTime() {
    return _getStartTime(
      reference.pointer,
      _id_getStartTime as jni$_.JMethodIDPtr,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_getEndTime = _class.instanceMethodId(
    r'getEndTime',
    r'()Ljava/time/Instant;',
  );

  static final _getEndTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.time.Instant getEndTime()`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? getEndTime() {
    return _getEndTime(
      reference.pointer,
      _id_getEndTime as jni$_.JMethodIDPtr,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_getLocalStartTime = _class.instanceMethodId(
    r'getLocalStartTime',
    r'()Ljava/time/LocalDateTime;',
  );

  static final _getLocalStartTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.time.LocalDateTime getLocalStartTime()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getLocalStartTime() {
    return _getLocalStartTime(
      reference.pointer,
      _id_getLocalStartTime as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getLocalEndTime = _class.instanceMethodId(
    r'getLocalEndTime',
    r'()Ljava/time/LocalDateTime;',
  );

  static final _getLocalEndTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.time.LocalDateTime getLocalEndTime()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getLocalEndTime() {
    return _getLocalEndTime(
      reference.pointer,
      _id_getLocalEndTime as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_new$2 = _class.constructorId(r'()V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory TimeRangeFilter.new$2() {
    return TimeRangeFilter.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
      ).reference,
    );
  }

  static final _id_between = _class.staticMethodId(
    r'between',
    r'(Ljava/time/Instant;Ljava/time/Instant;)Landroidx/health/connect/client/time/TimeRangeFilter;',
  );

  static final _between =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public final androidx.health.connect.client.time.TimeRangeFilter between(java.time.Instant instant, java.time.Instant instant1)`
  /// The returned object must be released after use, by calling the [release] method.
  static TimeRangeFilter between(Instant instant, Instant instant1) {
    final _$instant = instant.reference;
    final _$instant1 = instant1.reference;
    return _between(
      _class.reference.pointer,
      _id_between as jni$_.JMethodIDPtr,
      _$instant.pointer,
      _$instant1.pointer,
    ).object<TimeRangeFilter>(const $TimeRangeFilter$Type());
  }

  static final _id_between$1 = _class.staticMethodId(
    r'between',
    r'(Ljava/time/LocalDateTime;Ljava/time/LocalDateTime;)Landroidx/health/connect/client/time/TimeRangeFilter;',
  );

  static final _between$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public final androidx.health.connect.client.time.TimeRangeFilter between(java.time.LocalDateTime localDateTime, java.time.LocalDateTime localDateTime1)`
  /// The returned object must be released after use, by calling the [release] method.
  static TimeRangeFilter between$1(
    jni$_.JObject localDateTime,
    jni$_.JObject localDateTime1,
  ) {
    final _$localDateTime = localDateTime.reference;
    final _$localDateTime1 = localDateTime1.reference;
    return _between$1(
      _class.reference.pointer,
      _id_between$1 as jni$_.JMethodIDPtr,
      _$localDateTime.pointer,
      _$localDateTime1.pointer,
    ).object<TimeRangeFilter>(const $TimeRangeFilter$Type());
  }

  static final _id_before = _class.staticMethodId(
    r'before',
    r'(Ljava/time/Instant;)Landroidx/health/connect/client/time/TimeRangeFilter;',
  );

  static final _before =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public final androidx.health.connect.client.time.TimeRangeFilter before(java.time.Instant instant)`
  /// The returned object must be released after use, by calling the [release] method.
  static TimeRangeFilter before(Instant instant) {
    final _$instant = instant.reference;
    return _before(
      _class.reference.pointer,
      _id_before as jni$_.JMethodIDPtr,
      _$instant.pointer,
    ).object<TimeRangeFilter>(const $TimeRangeFilter$Type());
  }

  static final _id_before$1 = _class.staticMethodId(
    r'before',
    r'(Ljava/time/LocalDateTime;)Landroidx/health/connect/client/time/TimeRangeFilter;',
  );

  static final _before$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public final androidx.health.connect.client.time.TimeRangeFilter before(java.time.LocalDateTime localDateTime)`
  /// The returned object must be released after use, by calling the [release] method.
  static TimeRangeFilter before$1(jni$_.JObject localDateTime) {
    final _$localDateTime = localDateTime.reference;
    return _before$1(
      _class.reference.pointer,
      _id_before$1 as jni$_.JMethodIDPtr,
      _$localDateTime.pointer,
    ).object<TimeRangeFilter>(const $TimeRangeFilter$Type());
  }

  static final _id_after = _class.staticMethodId(
    r'after',
    r'(Ljava/time/Instant;)Landroidx/health/connect/client/time/TimeRangeFilter;',
  );

  static final _after =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public final androidx.health.connect.client.time.TimeRangeFilter after(java.time.Instant instant)`
  /// The returned object must be released after use, by calling the [release] method.
  static TimeRangeFilter after(Instant instant) {
    final _$instant = instant.reference;
    return _after(
      _class.reference.pointer,
      _id_after as jni$_.JMethodIDPtr,
      _$instant.pointer,
    ).object<TimeRangeFilter>(const $TimeRangeFilter$Type());
  }

  static final _id_after$1 = _class.staticMethodId(
    r'after',
    r'(Ljava/time/LocalDateTime;)Landroidx/health/connect/client/time/TimeRangeFilter;',
  );

  static final _after$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public final androidx.health.connect.client.time.TimeRangeFilter after(java.time.LocalDateTime localDateTime)`
  /// The returned object must be released after use, by calling the [release] method.
  static TimeRangeFilter after$1(jni$_.JObject localDateTime) {
    final _$localDateTime = localDateTime.reference;
    return _after$1(
      _class.reference.pointer,
      _id_after$1 as jni$_.JMethodIDPtr,
      _$localDateTime.pointer,
    ).object<TimeRangeFilter>(const $TimeRangeFilter$Type());
  }
}

final class $TimeRangeFilter$NullableType
    extends jni$_.JObjType<TimeRangeFilter?> {
  @jni$_.internal
  const $TimeRangeFilter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/time/TimeRangeFilter;';

  @jni$_.internal
  @core$_.override
  TimeRangeFilter? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : TimeRangeFilter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<TimeRangeFilter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($TimeRangeFilter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($TimeRangeFilter$NullableType) &&
        other is $TimeRangeFilter$NullableType;
  }
}

final class $TimeRangeFilter$Type extends jni$_.JObjType<TimeRangeFilter> {
  @jni$_.internal
  const $TimeRangeFilter$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/time/TimeRangeFilter;';

  @jni$_.internal
  @core$_.override
  TimeRangeFilter fromReference(jni$_.JReference reference) =>
      TimeRangeFilter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<TimeRangeFilter?> get nullableType =>
      const $TimeRangeFilter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($TimeRangeFilter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($TimeRangeFilter$Type) &&
        other is $TimeRangeFilter$Type;
  }
}

/// from: `androidx.health.connect.client.aggregate.AggregationResult`
class AggregationResult extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<AggregationResult> $type;

  @jni$_.internal
  AggregationResult.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/health/connect/client/aggregate/AggregationResult',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $AggregationResult$NullableType();
  static const type = $AggregationResult$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/util/Map;Ljava/util/Map;Ljava/util/Set;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.util.Map map, java.util.Map map1, java.util.Set set)`
  /// The returned object must be released after use, by calling the [release] method.
  factory AggregationResult(
    jni$_.JMap<jni$_.JString, jni$_.JLong> map,
    jni$_.JMap<jni$_.JString, jni$_.JDouble> map1,
    jni$_.JSet<jni$_.JObject> set,
  ) {
    final _$map = map.reference;
    final _$map1 = map1.reference;
    final _$set = set.reference;
    return AggregationResult.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$map.pointer,
        _$map1.pointer,
        _$set.pointer,
      ).reference,
    );
  }

  static final _id_getLongValues = _class.instanceMethodId(
    r'getLongValues',
    r'()Ljava/util/Map;',
  );

  static final _getLongValues =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map getLongValues()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JLong> getLongValues() {
    return _getLongValues(
      reference.pointer,
      _id_getLongValues as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JString, jni$_.JLong>>(
      const jni$_.JMapType<jni$_.JString, jni$_.JLong>(
        jni$_.JStringType(),
        jni$_.JLongType(),
      ),
    );
  }

  static final _id_getDoubleValues = _class.instanceMethodId(
    r'getDoubleValues',
    r'()Ljava/util/Map;',
  );

  static final _getDoubleValues =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map getDoubleValues()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JDouble> getDoubleValues() {
    return _getDoubleValues(
      reference.pointer,
      _id_getDoubleValues as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JString, jni$_.JDouble>>(
      const jni$_.JMapType<jni$_.JString, jni$_.JDouble>(
        jni$_.JStringType(),
        jni$_.JDoubleType(),
      ),
    );
  }

  static final _id_getDataOrigins = _class.instanceMethodId(
    r'getDataOrigins',
    r'()Ljava/util/Set;',
  );

  static final _getDataOrigins =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Set getDataOrigins()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<jni$_.JObject> getDataOrigins() {
    return _getDataOrigins(
      reference.pointer,
      _id_getDataOrigins as jni$_.JMethodIDPtr,
    ).object<jni$_.JSet<jni$_.JObject>>(
      const jni$_.JSetType<jni$_.JObject>(jni$_.JObjectType()),
    );
  }

  static final _id_contains = _class.instanceMethodId(
    r'contains',
    r'(Landroidx/health/connect/client/aggregate/AggregateMetric;)Z',
  );

  static final _contains =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final boolean contains(androidx.health.connect.client.aggregate.AggregateMetric aggregateMetric)`
  bool contains(AggregateMetric<jni$_.JObject> aggregateMetric) {
    final _$aggregateMetric = aggregateMetric.reference;
    return _contains(
      reference.pointer,
      _id_contains as jni$_.JMethodIDPtr,
      _$aggregateMetric.pointer,
    ).boolean;
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Landroidx/health/connect/client/aggregate/AggregateMetric;)Ljava/lang/Object;',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final T get(androidx.health.connect.client.aggregate.AggregateMetric aggregateMetric)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? get<$T extends jni$_.JObject>(
    AggregateMetric<$T> aggregateMetric, {
    jni$_.JObjType<$T>? T,
  }) {
    T ??=
        jni$_.lowestCommonSuperType([
              (aggregateMetric.$type as $AggregateMetric$Type<core$_.dynamic>)
                  .T,
            ])
            as jni$_.JObjType<$T>;
    final _$aggregateMetric = aggregateMetric.reference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$aggregateMetric.pointer,
    ).object<$T?>(T.nullableType);
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.JStringType());
  }

  // $T? operator [](AggregateMetric<$T> aggregateMetric) {
  //   return get(aggregateMetric);
  // }
}

final class $AggregationResult$NullableType
    extends jni$_.JObjType<AggregationResult?> {
  @jni$_.internal
  const $AggregationResult$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/aggregate/AggregationResult;';

  @jni$_.internal
  @core$_.override
  AggregationResult? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : AggregationResult.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AggregationResult?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AggregationResult$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AggregationResult$NullableType) &&
        other is $AggregationResult$NullableType;
  }
}

final class $AggregationResult$Type extends jni$_.JObjType<AggregationResult> {
  @jni$_.internal
  const $AggregationResult$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/aggregate/AggregationResult;';

  @jni$_.internal
  @core$_.override
  AggregationResult fromReference(jni$_.JReference reference) =>
      AggregationResult.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AggregationResult?> get nullableType =>
      const $AggregationResult$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AggregationResult$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AggregationResult$Type) &&
        other is $AggregationResult$Type;
  }
}

/// from: `androidx.health.connect.client.aggregate.AggregateMetric$AggregationType`
class AggregateMetric$AggregationType extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<AggregateMetric$AggregationType> $type;

  @jni$_.internal
  AggregateMetric$AggregationType.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/health/connect/client/aggregate/AggregateMetric$AggregationType',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $AggregateMetric$AggregationType$NullableType();
  static const type = $AggregateMetric$AggregationType$Type();
  static final _id_DURATION = _class.staticFieldId(
    r'DURATION',
    r'Landroidx/health/connect/client/aggregate/AggregateMetric$AggregationType;',
  );

  /// from: `static public final androidx.health.connect.client.aggregate.AggregateMetric$AggregationType DURATION`
  /// The returned object must be released after use, by calling the [release] method.
  static AggregateMetric$AggregationType get DURATION =>
      _id_DURATION.get(_class, const $AggregateMetric$AggregationType$Type());

  static final _id_AVERAGE = _class.staticFieldId(
    r'AVERAGE',
    r'Landroidx/health/connect/client/aggregate/AggregateMetric$AggregationType;',
  );

  /// from: `static public final androidx.health.connect.client.aggregate.AggregateMetric$AggregationType AVERAGE`
  /// The returned object must be released after use, by calling the [release] method.
  static AggregateMetric$AggregationType get AVERAGE =>
      _id_AVERAGE.get(_class, const $AggregateMetric$AggregationType$Type());

  static final _id_MINIMUM = _class.staticFieldId(
    r'MINIMUM',
    r'Landroidx/health/connect/client/aggregate/AggregateMetric$AggregationType;',
  );

  /// from: `static public final androidx.health.connect.client.aggregate.AggregateMetric$AggregationType MINIMUM`
  /// The returned object must be released after use, by calling the [release] method.
  static AggregateMetric$AggregationType get MINIMUM =>
      _id_MINIMUM.get(_class, const $AggregateMetric$AggregationType$Type());

  static final _id_MAXIMUM = _class.staticFieldId(
    r'MAXIMUM',
    r'Landroidx/health/connect/client/aggregate/AggregateMetric$AggregationType;',
  );

  /// from: `static public final androidx.health.connect.client.aggregate.AggregateMetric$AggregationType MAXIMUM`
  /// The returned object must be released after use, by calling the [release] method.
  static AggregateMetric$AggregationType get MAXIMUM =>
      _id_MAXIMUM.get(_class, const $AggregateMetric$AggregationType$Type());

  static final _id_TOTAL = _class.staticFieldId(
    r'TOTAL',
    r'Landroidx/health/connect/client/aggregate/AggregateMetric$AggregationType;',
  );

  /// from: `static public final androidx.health.connect.client.aggregate.AggregateMetric$AggregationType TOTAL`
  /// The returned object must be released after use, by calling the [release] method.
  static AggregateMetric$AggregationType get TOTAL =>
      _id_TOTAL.get(_class, const $AggregateMetric$AggregationType$Type());

  static final _id_COUNT = _class.staticFieldId(
    r'COUNT',
    r'Landroidx/health/connect/client/aggregate/AggregateMetric$AggregationType;',
  );

  /// from: `static public final androidx.health.connect.client.aggregate.AggregateMetric$AggregationType COUNT`
  /// The returned object must be released after use, by calling the [release] method.
  static AggregateMetric$AggregationType get COUNT =>
      _id_COUNT.get(_class, const $AggregateMetric$AggregationType$Type());

  static final _id_getAggregationTypeString = _class.instanceMethodId(
    r'getAggregationTypeString',
    r'()Ljava/lang/String;',
  );

  static final _getAggregationTypeString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getAggregationTypeString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getAggregationTypeString() {
    return _getAggregationTypeString(
      reference.pointer,
      _id_getAggregationTypeString as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Landroidx/health/connect/client/aggregate/AggregateMetric$AggregationType;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public androidx.health.connect.client.aggregate.AggregateMetric$AggregationType[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<AggregateMetric$AggregationType?>? values() {
    return _values(
      _class.reference.pointer,
      _id_values as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<AggregateMetric$AggregationType?>?>(
      const jni$_.JArrayNullableType<AggregateMetric$AggregationType?>(
        $AggregateMetric$AggregationType$NullableType(),
      ),
    );
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Landroidx/health/connect/client/aggregate/AggregateMetric$AggregationType;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public androidx.health.connect.client.aggregate.AggregateMetric$AggregationType valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static AggregateMetric$AggregationType? valueOf(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<AggregateMetric$AggregationType?>(
      const $AggregateMetric$AggregationType$NullableType(),
    );
  }

  static final _id_getEntries = _class.staticMethodId(
    r'getEntries',
    r'()Lkotlin/enums/EnumEntries;',
  );

  static final _getEntries =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public kotlin.enums.EnumEntries getEntries()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getEntries() {
    return _getEntries(
      _class.reference.pointer,
      _id_getEntries as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
  }
}

final class $AggregateMetric$AggregationType$NullableType
    extends jni$_.JObjType<AggregateMetric$AggregationType?> {
  @jni$_.internal
  const $AggregateMetric$AggregationType$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/aggregate/AggregateMetric$AggregationType;';

  @jni$_.internal
  @core$_.override
  AggregateMetric$AggregationType? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : AggregateMetric$AggregationType.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AggregateMetric$AggregationType?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AggregateMetric$AggregationType$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($AggregateMetric$AggregationType$NullableType) &&
        other is $AggregateMetric$AggregationType$NullableType;
  }
}

final class $AggregateMetric$AggregationType$Type
    extends jni$_.JObjType<AggregateMetric$AggregationType> {
  @jni$_.internal
  const $AggregateMetric$AggregationType$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/aggregate/AggregateMetric$AggregationType;';

  @jni$_.internal
  @core$_.override
  AggregateMetric$AggregationType fromReference(jni$_.JReference reference) =>
      AggregateMetric$AggregationType.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AggregateMetric$AggregationType?> get nullableType =>
      const $AggregateMetric$AggregationType$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AggregateMetric$AggregationType$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AggregateMetric$AggregationType$Type) &&
        other is $AggregateMetric$AggregationType$Type;
  }
}

/// from: `androidx.health.connect.client.aggregate.AggregateMetric$Companion`
class AggregateMetric$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<AggregateMetric$Companion> $type;

  @jni$_.internal
  AggregateMetric$Companion.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/health/connect/client/aggregate/AggregateMetric$Companion',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $AggregateMetric$Companion$NullableType();
  static const type = $AggregateMetric$Companion$Type();
  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory AggregateMetric$Companion(jni$_.JObject? defaultConstructorMarker) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return AggregateMetric$Companion.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }
}

final class $AggregateMetric$Companion$NullableType
    extends jni$_.JObjType<AggregateMetric$Companion?> {
  @jni$_.internal
  const $AggregateMetric$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/aggregate/AggregateMetric$Companion;';

  @jni$_.internal
  @core$_.override
  AggregateMetric$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : AggregateMetric$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AggregateMetric$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AggregateMetric$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AggregateMetric$Companion$NullableType) &&
        other is $AggregateMetric$Companion$NullableType;
  }
}

final class $AggregateMetric$Companion$Type
    extends jni$_.JObjType<AggregateMetric$Companion> {
  @jni$_.internal
  const $AggregateMetric$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/aggregate/AggregateMetric$Companion;';

  @jni$_.internal
  @core$_.override
  AggregateMetric$Companion fromReference(jni$_.JReference reference) =>
      AggregateMetric$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AggregateMetric$Companion?> get nullableType =>
      const $AggregateMetric$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AggregateMetric$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AggregateMetric$Companion$Type) &&
        other is $AggregateMetric$Companion$Type;
  }
}

/// from: `androidx.health.connect.client.aggregate.AggregateMetric$Converter$FromDouble`
class AggregateMetric$Converter$FromDouble<$R extends jni$_.JObject>
    extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<AggregateMetric$Converter$FromDouble<$R>> $type;

  @jni$_.internal
  final jni$_.JObjType<$R> R;

  @jni$_.internal
  AggregateMetric$Converter$FromDouble.fromReference(
    this.R,
    jni$_.JReference reference,
  ) : $type = type<$R>(R),
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/health/connect/client/aggregate/AggregateMetric$Converter$FromDouble',
  );

  /// The type which includes information such as the signature of this class.
  static $AggregateMetric$Converter$FromDouble$NullableType<$R>
  nullableType<$R extends jni$_.JObject>(jni$_.JObjType<$R> R) {
    return $AggregateMetric$Converter$FromDouble$NullableType<$R>(R);
  }

  static $AggregateMetric$Converter$FromDouble$Type<$R>
  type<$R extends jni$_.JObject>(jni$_.JObjType<$R> R) {
    return $AggregateMetric$Converter$FromDouble$Type<$R>(R);
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $AggregateMetric$Converter$FromDouble> _$impls =
      {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn<$R extends jni$_.JObject>(
    jni$_.JImplementer implementer,
    $AggregateMetric$Converter$FromDouble<$R> $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.health.connect.client.aggregate.AggregateMetric$Converter$FromDouble',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory AggregateMetric$Converter$FromDouble.implement(
    $AggregateMetric$Converter$FromDouble<$R> $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return AggregateMetric$Converter$FromDouble<$R>.fromReference(
      $impl.R,
      $i.implementReference(),
    );
  }
}

abstract base mixin class $AggregateMetric$Converter$FromDouble<
  $R extends jni$_.JObject
> {
  factory $AggregateMetric$Converter$FromDouble({
    required jni$_.JObjType<$R> R,
  }) = _$AggregateMetric$Converter$FromDouble<$R>;

  jni$_.JObjType<$R> get R;
}

final class _$AggregateMetric$Converter$FromDouble<$R extends jni$_.JObject>
    with $AggregateMetric$Converter$FromDouble<$R> {
  _$AggregateMetric$Converter$FromDouble({required this.R});

  @core$_.override
  final jni$_.JObjType<$R> R;
}

final class $AggregateMetric$Converter$FromDouble$NullableType<
  $R extends jni$_.JObject
>
    extends jni$_.JObjType<AggregateMetric$Converter$FromDouble<$R>?> {
  @jni$_.internal
  final jni$_.JObjType<$R> R;

  @jni$_.internal
  const $AggregateMetric$Converter$FromDouble$NullableType(this.R);

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/aggregate/AggregateMetric$Converter$FromDouble;';

  @jni$_.internal
  @core$_.override
  AggregateMetric$Converter$FromDouble<$R>? fromReference(
    jni$_.JReference reference,
  ) =>
      reference.isNull
          ? null
          : AggregateMetric$Converter$FromDouble<$R>.fromReference(
            R,
            reference,
          );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AggregateMetric$Converter$FromDouble<$R>?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      Object.hash($AggregateMetric$Converter$FromDouble$NullableType, R);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($AggregateMetric$Converter$FromDouble$NullableType<$R>) &&
        other is $AggregateMetric$Converter$FromDouble$NullableType<$R> &&
        R == other.R;
  }
}

final class $AggregateMetric$Converter$FromDouble$Type<$R extends jni$_.JObject>
    extends jni$_.JObjType<AggregateMetric$Converter$FromDouble<$R>> {
  @jni$_.internal
  final jni$_.JObjType<$R> R;

  @jni$_.internal
  const $AggregateMetric$Converter$FromDouble$Type(this.R);

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/aggregate/AggregateMetric$Converter$FromDouble;';

  @jni$_.internal
  @core$_.override
  AggregateMetric$Converter$FromDouble<$R> fromReference(
    jni$_.JReference reference,
  ) => AggregateMetric$Converter$FromDouble<$R>.fromReference(R, reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AggregateMetric$Converter$FromDouble<$R>?> get nullableType =>
      $AggregateMetric$Converter$FromDouble$NullableType<$R>(R);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      Object.hash($AggregateMetric$Converter$FromDouble$Type, R);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($AggregateMetric$Converter$FromDouble$Type<$R>) &&
        other is $AggregateMetric$Converter$FromDouble$Type<$R> &&
        R == other.R;
  }
}

/// from: `androidx.health.connect.client.aggregate.AggregateMetric$Converter$FromLong`
class AggregateMetric$Converter$FromLong<$R extends jni$_.JObject>
    extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<AggregateMetric$Converter$FromLong<$R>> $type;

  @jni$_.internal
  final jni$_.JObjType<$R> R;

  @jni$_.internal
  AggregateMetric$Converter$FromLong.fromReference(
    this.R,
    jni$_.JReference reference,
  ) : $type = type<$R>(R),
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/health/connect/client/aggregate/AggregateMetric$Converter$FromLong',
  );

  /// The type which includes information such as the signature of this class.
  static $AggregateMetric$Converter$FromLong$NullableType<$R>
  nullableType<$R extends jni$_.JObject>(jni$_.JObjType<$R> R) {
    return $AggregateMetric$Converter$FromLong$NullableType<$R>(R);
  }

  static $AggregateMetric$Converter$FromLong$Type<$R>
  type<$R extends jni$_.JObject>(jni$_.JObjType<$R> R) {
    return $AggregateMetric$Converter$FromLong$Type<$R>(R);
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $AggregateMetric$Converter$FromLong> _$impls =
      {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn<$R extends jni$_.JObject>(
    jni$_.JImplementer implementer,
    $AggregateMetric$Converter$FromLong<$R> $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.health.connect.client.aggregate.AggregateMetric$Converter$FromLong',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory AggregateMetric$Converter$FromLong.implement(
    $AggregateMetric$Converter$FromLong<$R> $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return AggregateMetric$Converter$FromLong<$R>.fromReference(
      $impl.R,
      $i.implementReference(),
    );
  }
}

abstract base mixin class $AggregateMetric$Converter$FromLong<
  $R extends jni$_.JObject
> {
  factory $AggregateMetric$Converter$FromLong({required jni$_.JObjType<$R> R}) =
      _$AggregateMetric$Converter$FromLong<$R>;

  jni$_.JObjType<$R> get R;
}

final class _$AggregateMetric$Converter$FromLong<$R extends jni$_.JObject>
    with $AggregateMetric$Converter$FromLong<$R> {
  _$AggregateMetric$Converter$FromLong({required this.R});

  @core$_.override
  final jni$_.JObjType<$R> R;
}

final class $AggregateMetric$Converter$FromLong$NullableType<
  $R extends jni$_.JObject
>
    extends jni$_.JObjType<AggregateMetric$Converter$FromLong<$R>?> {
  @jni$_.internal
  final jni$_.JObjType<$R> R;

  @jni$_.internal
  const $AggregateMetric$Converter$FromLong$NullableType(this.R);

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/aggregate/AggregateMetric$Converter$FromLong;';

  @jni$_.internal
  @core$_.override
  AggregateMetric$Converter$FromLong<$R>? fromReference(
    jni$_.JReference reference,
  ) =>
      reference.isNull
          ? null
          : AggregateMetric$Converter$FromLong<$R>.fromReference(R, reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AggregateMetric$Converter$FromLong<$R>?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      Object.hash($AggregateMetric$Converter$FromLong$NullableType, R);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($AggregateMetric$Converter$FromLong$NullableType<$R>) &&
        other is $AggregateMetric$Converter$FromLong$NullableType<$R> &&
        R == other.R;
  }
}

final class $AggregateMetric$Converter$FromLong$Type<$R extends jni$_.JObject>
    extends jni$_.JObjType<AggregateMetric$Converter$FromLong<$R>> {
  @jni$_.internal
  final jni$_.JObjType<$R> R;

  @jni$_.internal
  const $AggregateMetric$Converter$FromLong$Type(this.R);

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/aggregate/AggregateMetric$Converter$FromLong;';

  @jni$_.internal
  @core$_.override
  AggregateMetric$Converter$FromLong<$R> fromReference(
    jni$_.JReference reference,
  ) => AggregateMetric$Converter$FromLong<$R>.fromReference(R, reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AggregateMetric$Converter$FromLong<$R>?> get nullableType =>
      $AggregateMetric$Converter$FromLong$NullableType<$R>(R);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($AggregateMetric$Converter$FromLong$Type, R);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($AggregateMetric$Converter$FromLong$Type<$R>) &&
        other is $AggregateMetric$Converter$FromLong$Type<$R> &&
        R == other.R;
  }
}

/// from: `androidx.health.connect.client.aggregate.AggregateMetric$Converter`
class AggregateMetric$Converter<
  $T extends jni$_.JObject,
  $R extends jni$_.JObject
>
    extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<AggregateMetric$Converter<$T, $R>> $type;

  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  final jni$_.JObjType<$R> R;

  @jni$_.internal
  AggregateMetric$Converter.fromReference(
    this.T,
    this.R,
    jni$_.JReference reference,
  ) : $type = type<$T, $R>(T, R),
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/health/connect/client/aggregate/AggregateMetric$Converter',
  );

  /// The type which includes information such as the signature of this class.
  static $AggregateMetric$Converter$NullableType<$T, $R> nullableType<
    $T extends jni$_.JObject,
    $R extends jni$_.JObject
  >(jni$_.JObjType<$T> T, jni$_.JObjType<$R> R) {
    return $AggregateMetric$Converter$NullableType<$T, $R>(T, R);
  }

  static $AggregateMetric$Converter$Type<$T, $R> type<
    $T extends jni$_.JObject,
    $R extends jni$_.JObject
  >(jni$_.JObjType<$T> T, jni$_.JObjType<$R> R) {
    return $AggregateMetric$Converter$Type<$T, $R>(T, R);
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $AggregateMetric$Converter> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn<$T extends jni$_.JObject, $R extends jni$_.JObject>(
    jni$_.JImplementer implementer,
    $AggregateMetric$Converter<$T, $R> $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.health.connect.client.aggregate.AggregateMetric$Converter',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory AggregateMetric$Converter.implement(
    $AggregateMetric$Converter<$T, $R> $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return AggregateMetric$Converter<$T, $R>.fromReference(
      $impl.T,
      $impl.R,
      $i.implementReference(),
    );
  }
}

abstract base mixin class $AggregateMetric$Converter<
  $T extends jni$_.JObject,
  $R extends jni$_.JObject
> {
  factory $AggregateMetric$Converter({
    required jni$_.JObjType<$T> T,
    required jni$_.JObjType<$R> R,
  }) = _$AggregateMetric$Converter<$T, $R>;

  jni$_.JObjType<$T> get T;
  jni$_.JObjType<$R> get R;
}

final class _$AggregateMetric$Converter<
  $T extends jni$_.JObject,
  $R extends jni$_.JObject
>
    with $AggregateMetric$Converter<$T, $R> {
  _$AggregateMetric$Converter({required this.T, required this.R});

  @core$_.override
  final jni$_.JObjType<$T> T;

  @core$_.override
  final jni$_.JObjType<$R> R;
}

final class $AggregateMetric$Converter$NullableType<
  $T extends jni$_.JObject,
  $R extends jni$_.JObject
>
    extends jni$_.JObjType<AggregateMetric$Converter<$T, $R>?> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  final jni$_.JObjType<$R> R;

  @jni$_.internal
  const $AggregateMetric$Converter$NullableType(this.T, this.R);

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/aggregate/AggregateMetric$Converter;';

  @jni$_.internal
  @core$_.override
  AggregateMetric$Converter<$T, $R>? fromReference(
    jni$_.JReference reference,
  ) =>
      reference.isNull
          ? null
          : AggregateMetric$Converter<$T, $R>.fromReference(T, R, reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AggregateMetric$Converter<$T, $R>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      Object.hash($AggregateMetric$Converter$NullableType, T, R);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($AggregateMetric$Converter$NullableType<$T, $R>) &&
        other is $AggregateMetric$Converter$NullableType<$T, $R> &&
        T == other.T &&
        R == other.R;
  }
}

final class $AggregateMetric$Converter$Type<
  $T extends jni$_.JObject,
  $R extends jni$_.JObject
>
    extends jni$_.JObjType<AggregateMetric$Converter<$T, $R>> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  final jni$_.JObjType<$R> R;

  @jni$_.internal
  const $AggregateMetric$Converter$Type(this.T, this.R);

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/aggregate/AggregateMetric$Converter;';

  @jni$_.internal
  @core$_.override
  AggregateMetric$Converter<$T, $R> fromReference(jni$_.JReference reference) =>
      AggregateMetric$Converter<$T, $R>.fromReference(T, R, reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AggregateMetric$Converter<$T, $R>?> get nullableType =>
      $AggregateMetric$Converter$NullableType<$T, $R>(T, R);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($AggregateMetric$Converter$Type, T, R);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AggregateMetric$Converter$Type<$T, $R>) &&
        other is $AggregateMetric$Converter$Type<$T, $R> &&
        T == other.T &&
        R == other.R;
  }
}

/// from: `androidx.health.connect.client.aggregate.AggregateMetric`
class AggregateMetric<$T extends jni$_.JObject> extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<AggregateMetric<$T>> $type;

  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  AggregateMetric.fromReference(this.T, jni$_.JReference reference)
    : $type = type<$T>(T),
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/health/connect/client/aggregate/AggregateMetric',
  );

  /// The type which includes information such as the signature of this class.
  static $AggregateMetric$NullableType<$T>
  nullableType<$T extends jni$_.JObject>(jni$_.JObjType<$T> T) {
    return $AggregateMetric$NullableType<$T>(T);
  }

  static $AggregateMetric$Type<$T> type<$T extends jni$_.JObject>(
    jni$_.JObjType<$T> T,
  ) {
    return $AggregateMetric$Type<$T>(T);
  }

  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Landroidx/health/connect/client/aggregate/AggregateMetric$Companion;',
  );

  /// from: `static public final androidx.health.connect.client.aggregate.AggregateMetric$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static AggregateMetric$Companion get Companion =>
      _id_Companion.get(_class, const $AggregateMetric$Companion$Type());

  static final _id_new$ = _class.constructorId(
    r'(Landroidx/health/connect/client/aggregate/AggregateMetric$Converter;Ljava/lang/String;Landroidx/health/connect/client/aggregate/AggregateMetric$AggregationType;Ljava/lang/String;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(androidx.health.connect.client.aggregate.AggregateMetric$Converter converter, java.lang.String string, androidx.health.connect.client.aggregate.AggregateMetric$AggregationType aggregationType, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory AggregateMetric(
    AggregateMetric$Converter<jni$_.JObject, $T> converter,
    jni$_.JString string,
    AggregateMetric$AggregationType aggregationType,
    jni$_.JString? string1, {
    jni$_.JObjType<$T>? T,
  }) {
    T ??=
        jni$_.lowestCommonSuperType([
              (converter.$type
                      as $AggregateMetric$Converter$Type<
                        core$_.dynamic,
                        core$_.dynamic
                      >)
                  .R,
            ])
            as jni$_.JObjType<$T>;
    final _$converter = converter.reference;
    final _$string = string.reference;
    final _$aggregationType = aggregationType.reference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return AggregateMetric<$T>.fromReference(
      T,
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$converter.pointer,
        _$string.pointer,
        _$aggregationType.pointer,
        _$string1.pointer,
      ).reference,
    );
  }

  static final _id_getMetricKey = _class.instanceMethodId(
    r'getMetricKey',
    r'()Ljava/lang/String;',
  );

  static final _getMetricKey =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getMetricKey()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getMetricKey() {
    return _getMetricKey(
      reference.pointer,
      _id_getMetricKey as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.JStringType());
  }
}

final class $AggregateMetric$NullableType<$T extends jni$_.JObject>
    extends jni$_.JObjType<AggregateMetric<$T>?> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $AggregateMetric$NullableType(this.T);

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/aggregate/AggregateMetric;';

  @jni$_.internal
  @core$_.override
  AggregateMetric<$T>? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : AggregateMetric<$T>.fromReference(T, reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AggregateMetric<$T>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($AggregateMetric$NullableType, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AggregateMetric$NullableType<$T>) &&
        other is $AggregateMetric$NullableType<$T> &&
        T == other.T;
  }
}

final class $AggregateMetric$Type<$T extends jni$_.JObject>
    extends jni$_.JObjType<AggregateMetric<$T>> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $AggregateMetric$Type(this.T);

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/aggregate/AggregateMetric;';

  @jni$_.internal
  @core$_.override
  AggregateMetric<$T> fromReference(jni$_.JReference reference) =>
      AggregateMetric<$T>.fromReference(T, reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AggregateMetric<$T>?> get nullableType =>
      $AggregateMetric$NullableType<$T>(T);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($AggregateMetric$Type, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AggregateMetric$Type<$T>) &&
        other is $AggregateMetric$Type<$T> &&
        T == other.T;
  }
}

/// from: `androidx.health.connect.client.records.StepsRecord$Companion`
class StepsRecord$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<StepsRecord$Companion> $type;

  @jni$_.internal
  StepsRecord$Companion.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/health/connect/client/records/StepsRecord$Companion',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $StepsRecord$Companion$NullableType();
  static const type = $StepsRecord$Companion$Type();
  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory StepsRecord$Companion(jni$_.JObject? defaultConstructorMarker) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return StepsRecord$Companion.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }
}

final class $StepsRecord$Companion$NullableType
    extends jni$_.JObjType<StepsRecord$Companion?> {
  @jni$_.internal
  const $StepsRecord$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/records/StepsRecord$Companion;';

  @jni$_.internal
  @core$_.override
  StepsRecord$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : StepsRecord$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StepsRecord$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($StepsRecord$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StepsRecord$Companion$NullableType) &&
        other is $StepsRecord$Companion$NullableType;
  }
}

final class $StepsRecord$Companion$Type
    extends jni$_.JObjType<StepsRecord$Companion> {
  @jni$_.internal
  const $StepsRecord$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/records/StepsRecord$Companion;';

  @jni$_.internal
  @core$_.override
  StepsRecord$Companion fromReference(jni$_.JReference reference) =>
      StepsRecord$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StepsRecord$Companion?> get nullableType =>
      const $StepsRecord$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($StepsRecord$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StepsRecord$Companion$Type) &&
        other is $StepsRecord$Companion$Type;
  }
}

/// from: `androidx.health.connect.client.records.StepsRecord`
class StepsRecord extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<StepsRecord> $type;

  @jni$_.internal
  StepsRecord.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/health/connect/client/records/StepsRecord',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $StepsRecord$NullableType();
  static const type = $StepsRecord$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Landroidx/health/connect/client/records/StepsRecord$Companion;',
  );

  /// from: `static public final androidx.health.connect.client.records.StepsRecord$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static StepsRecord$Companion get Companion =>
      _id_Companion.get(_class, const $StepsRecord$Companion$Type());

  static final _id_COUNT_TOTAL = _class.staticFieldId(
    r'COUNT_TOTAL',
    r'Landroidx/health/connect/client/aggregate/AggregateMetric;',
  );

  /// from: `static public final androidx.health.connect.client.aggregate.AggregateMetric COUNT_TOTAL`
  /// The returned object must be released after use, by calling the [release] method.
  static AggregateMetric<jni$_.JLong> get COUNT_TOTAL => _id_COUNT_TOTAL.get(
    _class,
    const $AggregateMetric$Type<jni$_.JLong>(jni$_.JLongType()),
  );

  static final _id_new$ = _class.constructorId(
    r'(Ljava/time/Instant;Ljava/time/ZoneOffset;Ljava/time/Instant;Ljava/time/ZoneOffset;JLandroidx/health/connect/client/records/metadata/Metadata;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int64,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.time.Instant instant, java.time.ZoneOffset zoneOffset, java.time.Instant instant1, java.time.ZoneOffset zoneOffset1, long j, androidx.health.connect.client.records.metadata.Metadata metadata)`
  /// The returned object must be released after use, by calling the [release] method.
  factory StepsRecord(
    Instant instant,
    jni$_.JObject? zoneOffset,
    Instant instant1,
    jni$_.JObject? zoneOffset1,
    int j,
    jni$_.JObject metadata,
  ) {
    final _$instant = instant.reference;
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    final _$instant1 = instant1.reference;
    final _$zoneOffset1 = zoneOffset1?.reference ?? jni$_.jNullReference;
    final _$metadata = metadata.reference;
    return StepsRecord.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$instant.pointer,
        _$zoneOffset.pointer,
        _$instant1.pointer,
        _$zoneOffset1.pointer,
        j,
        _$metadata.pointer,
      ).reference,
    );
  }

  static final _id_getStartTime = _class.instanceMethodId(
    r'getStartTime',
    r'()Ljava/time/Instant;',
  );

  static final _getStartTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Instant getStartTime()`
  /// The returned object must be released after use, by calling the [release] method.
  Instant getStartTime() {
    return _getStartTime(
      reference.pointer,
      _id_getStartTime as jni$_.JMethodIDPtr,
    ).object<Instant>(const $Instant$Type());
  }

  static final _id_getStartZoneOffset = _class.instanceMethodId(
    r'getStartZoneOffset',
    r'()Ljava/time/ZoneOffset;',
  );

  static final _getStartZoneOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.ZoneOffset getStartZoneOffset()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getStartZoneOffset() {
    return _getStartZoneOffset(
      reference.pointer,
      _id_getStartZoneOffset as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getEndTime = _class.instanceMethodId(
    r'getEndTime',
    r'()Ljava/time/Instant;',
  );

  static final _getEndTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Instant getEndTime()`
  /// The returned object must be released after use, by calling the [release] method.
  Instant getEndTime() {
    return _getEndTime(
      reference.pointer,
      _id_getEndTime as jni$_.JMethodIDPtr,
    ).object<Instant>(const $Instant$Type());
  }

  static final _id_getEndZoneOffset = _class.instanceMethodId(
    r'getEndZoneOffset',
    r'()Ljava/time/ZoneOffset;',
  );

  static final _getEndZoneOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.ZoneOffset getEndZoneOffset()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getEndZoneOffset() {
    return _getEndZoneOffset(
      reference.pointer,
      _id_getEndZoneOffset as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getCount = _class.instanceMethodId(r'getCount', r'()J');

  static final _getCount =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final long getCount()`
  int getCount() {
    return _getCount(
      reference.pointer,
      _id_getCount as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_getMetadata = _class.instanceMethodId(
    r'getMetadata',
    r'()Landroidx/health/connect/client/records/metadata/Metadata;',
  );

  static final _getMetadata =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.health.connect.client.records.metadata.Metadata getMetadata()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getMetadata() {
    return _getMetadata(
      reference.pointer,
      _id_getMetadata as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.JStringType());
  }
}

final class $StepsRecord$NullableType extends jni$_.JObjType<StepsRecord?> {
  @jni$_.internal
  const $StepsRecord$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/records/StepsRecord;';

  @jni$_.internal
  @core$_.override
  StepsRecord? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : StepsRecord.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StepsRecord?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($StepsRecord$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StepsRecord$NullableType) &&
        other is $StepsRecord$NullableType;
  }
}

final class $StepsRecord$Type extends jni$_.JObjType<StepsRecord> {
  @jni$_.internal
  const $StepsRecord$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/health/connect/client/records/StepsRecord;';

  @jni$_.internal
  @core$_.override
  StepsRecord fromReference(jni$_.JReference reference) =>
      StepsRecord.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StepsRecord?> get nullableType =>
      const $StepsRecord$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($StepsRecord$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StepsRecord$Type) &&
        other is $StepsRecord$Type;
  }
}

/// from: `java.time.Instant`
class Instant extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Instant> $type;

  @jni$_.internal
  Instant.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/Instant');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Instant$NullableType();
  static const type = $Instant$Type();
  static final _id_EPOCH = _class.staticFieldId(
    r'EPOCH',
    r'Ljava/time/Instant;',
  );

  /// from: `static public final java.time.Instant EPOCH`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? get EPOCH =>
      _id_EPOCH.get(_class, const $Instant$NullableType());

  static final _id_MAX = _class.staticFieldId(r'MAX', r'Ljava/time/Instant;');

  /// from: `static public final java.time.Instant MAX`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? get MAX => _id_MAX.get(_class, const $Instant$NullableType());

  static final _id_MIN = _class.staticFieldId(r'MIN', r'Ljava/time/Instant;');

  /// from: `static public final java.time.Instant MIN`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? get MIN => _id_MIN.get(_class, const $Instant$NullableType());

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? adjustInto(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(
      reference.pointer,
      _id_adjustInto as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_atOffset = _class.instanceMethodId(
    r'atOffset',
    r'(Ljava/time/ZoneOffset;)Ljava/time/OffsetDateTime;',
  );

  static final _atOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetDateTime atOffset(java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? atOffset(jni$_.JObject? zoneOffset) {
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _atOffset(
      reference.pointer,
      _id_atOffset as jni$_.JMethodIDPtr,
      _$zoneOffset.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_atZone = _class.instanceMethodId(
    r'atZone',
    r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _atZone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.ZonedDateTime atZone(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? atZone(jni$_.JObject? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _atZone(
      reference.pointer,
      _id_atZone as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/time/Instant;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.time.Instant instant)`
  int compareTo(Instant? instant) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$instant.pointer,
    ).integer;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/Instant;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Instant from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? from(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).integer;
  }

  static final _id_getEpochSecond = _class.instanceMethodId(
    r'getEpochSecond',
    r'()J',
  );

  static final _getEpochSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getEpochSecond()`
  int getEpochSecond() {
    return _getEpochSecond(
      reference.pointer,
      _id_getEpochSecond as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(
      reference.pointer,
      _id_getLong as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).long;
  }

  static final _id_getNano = _class.instanceMethodId(r'getNano', r'()I');

  static final _getNano =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getNano()`
  int getNano() {
    return _getNano(
      reference.pointer,
      _id_getNano as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_isAfter = _class.instanceMethodId(
    r'isAfter',
    r'(Ljava/time/Instant;)Z',
  );

  static final _isAfter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isAfter(java.time.Instant instant)`
  bool isAfter(Instant? instant) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    return _isAfter(
      reference.pointer,
      _id_isAfter as jni$_.JMethodIDPtr,
      _$instant.pointer,
    ).boolean;
  }

  static final _id_isBefore = _class.instanceMethodId(
    r'isBefore',
    r'(Ljava/time/Instant;)Z',
  );

  static final _isBefore =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isBefore(java.time.Instant instant)`
  bool isBefore(Instant? instant) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    return _isBefore(
      reference.pointer,
      _id_isBefore as jni$_.JMethodIDPtr,
      _$instant.pointer,
    ).boolean;
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(
      reference.pointer,
      _id_isSupported as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).boolean;
  }

  static final _id_isSupported$1 = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalUnit;)Z',
  );

  static final _isSupported$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalUnit temporalUnit)`
  bool isSupported$1(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _isSupported$1(
      reference.pointer,
      _id_isSupported$1 as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).boolean;
  }

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/Instant;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Instant minus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? minus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _minus(
      reference.pointer,
      _id_minus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_minus$1 = _class.instanceMethodId(
    r'minus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/Instant;',
  );

  static final _minus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Instant minus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? minus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _minus$1(
      reference.pointer,
      _id_minus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_minusMillis = _class.instanceMethodId(
    r'minusMillis',
    r'(J)Ljava/time/Instant;',
  );

  static final _minusMillis =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Instant minusMillis(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? minusMillis(int j) {
    return _minusMillis(
      reference.pointer,
      _id_minusMillis as jni$_.JMethodIDPtr,
      j,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_minusNanos = _class.instanceMethodId(
    r'minusNanos',
    r'(J)Ljava/time/Instant;',
  );

  static final _minusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Instant minusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? minusNanos(int j) {
    return _minusNanos(
      reference.pointer,
      _id_minusNanos as jni$_.JMethodIDPtr,
      j,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_minusSeconds = _class.instanceMethodId(
    r'minusSeconds',
    r'(J)Ljava/time/Instant;',
  );

  static final _minusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Instant minusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? minusSeconds(int j) {
    return _minusSeconds(
      reference.pointer,
      _id_minusSeconds as jni$_.JMethodIDPtr,
      j,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_now = _class.staticMethodId(
    r'now',
    r'()Ljava/time/Instant;',
  );

  static final _now =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.Instant now()`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? now() {
    return _now(
      _class.reference.pointer,
      _id_now as jni$_.JMethodIDPtr,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_now$1 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/Clock;)Ljava/time/Instant;',
  );

  static final _now$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Instant now(java.time.Clock clock)`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? now$1(jni$_.JObject? clock) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    return _now$1(
      _class.reference.pointer,
      _id_now$1 as jni$_.JMethodIDPtr,
      _$clock.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_ofEpochMilli = _class.staticMethodId(
    r'ofEpochMilli',
    r'(J)Ljava/time/Instant;',
  );

  static final _ofEpochMilli =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Instant ofEpochMilli(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? ofEpochMilli(int j) {
    return _ofEpochMilli(
      _class.reference.pointer,
      _id_ofEpochMilli as jni$_.JMethodIDPtr,
      j,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_ofEpochSecond = _class.staticMethodId(
    r'ofEpochSecond',
    r'(J)Ljava/time/Instant;',
  );

  static final _ofEpochSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Instant ofEpochSecond(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? ofEpochSecond(int j) {
    return _ofEpochSecond(
      _class.reference.pointer,
      _id_ofEpochSecond as jni$_.JMethodIDPtr,
      j,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_ofEpochSecond$1 = _class.staticMethodId(
    r'ofEpochSecond',
    r'(JJ)Ljava/time/Instant;',
  );

  static final _ofEpochSecond$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `static public java.time.Instant ofEpochSecond(long j, long j1)`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? ofEpochSecond$1(int j, int j1) {
    return _ofEpochSecond$1(
      _class.reference.pointer,
      _id_ofEpochSecond$1 as jni$_.JMethodIDPtr,
      j,
      j1,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/Instant;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Instant parse(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? parse(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/Instant;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Instant plus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? plus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _plus(
      reference.pointer,
      _id_plus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plus$1 = _class.instanceMethodId(
    r'plus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/Instant;',
  );

  static final _plus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Instant plus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? plus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _plus$1(
      reference.pointer,
      _id_plus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plusMillis = _class.instanceMethodId(
    r'plusMillis',
    r'(J)Ljava/time/Instant;',
  );

  static final _plusMillis =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Instant plusMillis(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? plusMillis(int j) {
    return _plusMillis(
      reference.pointer,
      _id_plusMillis as jni$_.JMethodIDPtr,
      j,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plusNanos = _class.instanceMethodId(
    r'plusNanos',
    r'(J)Ljava/time/Instant;',
  );

  static final _plusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Instant plusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? plusNanos(int j) {
    return _plusNanos(
      reference.pointer,
      _id_plusNanos as jni$_.JMethodIDPtr,
      j,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plusSeconds = _class.instanceMethodId(
    r'plusSeconds',
    r'(J)Ljava/time/Instant;',
  );

  static final _plusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Instant plusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? plusSeconds(int j) {
    return _plusSeconds(
      reference.pointer,
      _id_plusSeconds as jni$_.JMethodIDPtr,
      j,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(
      reference.pointer,
      _id_query as jni$_.JMethodIDPtr,
      _$temporalQuery.pointer,
    ).object<$R?>(R.nullableType);
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_toEpochMilli = _class.instanceMethodId(
    r'toEpochMilli',
    r'()J',
  );

  static final _toEpochMilli =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long toEpochMilli()`
  int toEpochMilli() {
    return _toEpochMilli(
      reference.pointer,
      _id_toEpochMilli as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_truncatedTo = _class.instanceMethodId(
    r'truncatedTo',
    r'(Ljava/time/temporal/TemporalUnit;)Ljava/time/Instant;',
  );

  static final _truncatedTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Instant truncatedTo(java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? truncatedTo(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _truncatedTo(
      reference.pointer,
      _id_truncatedTo as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_until = _class.instanceMethodId(
    r'until',
    r'(Ljava/time/temporal/Temporal;Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _until =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long until(java.time.temporal.Temporal temporal, java.time.temporal.TemporalUnit temporalUnit)`
  int until(jni$_.JObject? temporal, jni$_.JObject? temporalUnit) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _until(
      reference.pointer,
      _id_until as jni$_.JMethodIDPtr,
      _$temporal.pointer,
      _$temporalUnit.pointer,
    ).long;
  }

  static final _id_with$ = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalAdjuster;)Ljava/time/Instant;',
  );

  static final _with$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Instant with(java.time.temporal.TemporalAdjuster temporalAdjuster)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? with$(jni$_.JObject? temporalAdjuster) {
    final _$temporalAdjuster =
        temporalAdjuster?.reference ?? jni$_.jNullReference;
    return _with$(
      reference.pointer,
      _id_with$ as jni$_.JMethodIDPtr,
      _$temporalAdjuster.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_with$1 = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalField;J)Ljava/time/Instant;',
  );

  static final _with$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public java.time.Instant with(java.time.temporal.TemporalField temporalField, long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? with$1(jni$_.JObject? temporalField, int j) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _with$1(
      reference.pointer,
      _id_with$1 as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
      j,
    ).object<Instant?>(const $Instant$NullableType());
  }

  bool operator <(Instant? instant) {
    return compareTo(instant) < 0;
  }

  bool operator <=(Instant? instant) {
    return compareTo(instant) <= 0;
  }

  bool operator >(Instant? instant) {
    return compareTo(instant) > 0;
  }

  bool operator >=(Instant? instant) {
    return compareTo(instant) >= 0;
  }
}

final class $Instant$NullableType extends jni$_.JObjType<Instant?> {
  @jni$_.internal
  const $Instant$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Instant;';

  @jni$_.internal
  @core$_.override
  Instant? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Instant.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Instant?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Instant$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Instant$NullableType) &&
        other is $Instant$NullableType;
  }
}

final class $Instant$Type extends jni$_.JObjType<Instant> {
  @jni$_.internal
  const $Instant$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Instant;';

  @jni$_.internal
  @core$_.override
  Instant fromReference(jni$_.JReference reference) =>
      Instant.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Instant?> get nullableType => const $Instant$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Instant$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Instant$Type) && other is $Instant$Type;
  }
}
